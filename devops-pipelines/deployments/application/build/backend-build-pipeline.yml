trigger:
  batch: true
  branches:
    include:
      - main
      - HA/devops-stuff
  paths:
    include:
      - backend/*

pr:
  branches:
    include:
      - main
      - HA/devops-stuff
  paths:
    include:
      - backend/*

variables:
  buildConfiguration: 'Release'
  dotNetVersion: '8.x'
  testResultsDirectory: '$(Agent.TempDirectory)/TestResults'
  coverageReportsDirectory: '$(Agent.TempDirectory)/CoverageReports'

stages:
  - stage: Build_And_Test_Backend
    displayName: 'LACC Backend - Build, Test & Package'
    jobs:
      - job: Build_Solution
        displayName: 'LACC - Build Backend Solution'
        pool:
          vmImage: ubuntu-latest
        steps:
          - task: UseDotNet@2
            displayName: 'Use .NET SDK'
            inputs:
              packageType: 'sdk'
              version: $(dotNetVersion)

          - task: DotNetCoreCLI@2
            displayName: 'Restore NuGet Packages'
            inputs:
              command: 'restore'
              projects: 'backend/CPS.ComplexCases.sln'
              feedsToUse: 'select'

          - task: DotNetCoreCLI@2
            displayName: 'Build Solution'
            inputs:
              command: 'build'
              projects: 'backend/CPS.ComplexCases.sln'
              arguments: '--configuration $(buildConfiguration) --no-restore'

          - task: DotNetCoreCLI@2
            displayName: 'Run All Tests'
            inputs:
              command: 'test'
              projects: 'backend/**/*Tests.csproj'
              arguments: '--configuration $(buildConfiguration) --no-build --collect:"XPlat Code Coverage" --settings backend/CodeCoverage.runsettings'
              publishTestResults: true
              testResultsFormat: 'VSTest'
              testResultsFiles: '**/*.trx'
            continueOnError: true



          - task: PublishCodeCoverageResults@1
            displayName: 'Publish Code Coverage'
            inputs:
              codeCoverageTool: 'Cobertura'
              summaryFileLocation: '$(Agent.TempDirectory)/**/coverage.cobertura.xml'
              reportDirectory: '$(coverageReportsDirectory)'
            condition: always()

          - task: DotNetCoreCLI@2
            displayName: 'Install ReportGenerator Tool'
            inputs:
              command: 'custom'
              custom: 'tool'
              arguments: 'install --global dotnet-reportgenerator-globaltool'
            condition: always()

          - task: PowerShell@2
            displayName: 'Generate Beautiful HTML Coverage Report'
            inputs:
              targetType: 'inline'
              script: |
                # Find all coverage files
                $coverageFiles = Get-ChildItem -Path "$(Agent.TempDirectory)" -Filter "coverage.cobertura.xml" -Recurse
                
                if ($coverageFiles.Count -gt 0) {
                  $coverageFilePaths = $coverageFiles.FullName -join ";"
                  
                  # Generate beautiful HTML report
                  reportgenerator `
                    -reports:"$coverageFilePaths" `
                    -targetdir:"$(coverageReportsDirectory)/html" `
                    -reporttypes:"Html;HtmlSummary;Badges;TextSummary" `
                    -historydir:"$(coverageReportsDirectory)/history" `
                    -title:"CPS Complex Cases Backend Coverage Report" `
                    -tag:"$(Build.BuildNumber)" `
                    -assemblyfilters:"+*;-*.Tests;-*.WireMock" `
                    -classfilters:"+*;-*Tests*;-*Mock*;-*Migrations*" `
                    -verbosity:"Info"
                  
                  Write-Host "Coverage report generated successfully"
                  Write-Host "Report location: $(coverageReportsDirectory)/html"
                } else {
                  Write-Host "No coverage files found"
                }
            condition: always()

          - task: PublishBuildArtifacts@1
            displayName: 'Publish HTML Coverage Report'
            inputs:
              pathtoPublish: '$(coverageReportsDirectory)/html'
              artifactName: 'backend-coverage-report'
            condition: always()

      - job: Build_Main_API
        displayName: 'LACC - Build Main API Function App'
        dependsOn: Build_Solution
        pool:
          vmImage: ubuntu-latest
        steps:
          - task: UseDotNet@2
            displayName: 'Use .NET SDK'
            inputs:
              packageType: 'sdk'
              version: $(dotNetVersion)

          - task: DotNetCoreCLI@2
            displayName: 'Restore Main API'
            inputs:
              command: 'restore'
              projects: 'backend/CPS.ComplexCases.API/CPS.ComplexCases.API.csproj'

          - task: DotNetCoreCLI@2
            displayName: 'Build Main API'
            inputs:
              command: 'build'
              projects: 'backend/CPS.ComplexCases.API/CPS.ComplexCases.API.csproj'
              arguments: '--configuration $(buildConfiguration)'

          - task: DotNetCoreCLI@2
            displayName: 'Publish Main API'
            inputs:
              command: 'publish'
              projects: 'backend/CPS.ComplexCases.API/CPS.ComplexCases.API.csproj'
              publishWebProjects: false
              zipAfterPublish: false
              arguments: '--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)/MainAPI --no-restore /p:SourceRevisionId=$(Build.SourceVersion) /p:PublishUrl=$(Build.ArtifactStagingDirectory)/MainAPI'

          - task: Bash@3
            displayName: 'Debug - List Main API Output Structure'
            inputs:
              targetType: 'inline'
              script: |
                echo "Checking Main API output structure:"
                echo "Contents of $(Build.ArtifactStagingDirectory)/MainAPI:"
                find "$(Build.ArtifactStagingDirectory)/MainAPI" -type f | sed "s|$(Build.ArtifactStagingDirectory)/MainAPI||" | head -20

          - task: Bash@3
            displayName: 'Fix Main API Folder Structure and Archive'
            inputs:
              targetType: 'inline'
              script: |
                mainApiPath="$(Build.ArtifactStagingDirectory)/MainAPI"
                zipFile="$(Build.ArtifactStagingDirectory)/lacc-main-api-$(Build.BuildId).zip"
                
                echo "Checking for nested folder structure..."
                
                # Check if there's a nested project folder (common with .NET publish)
                nestedFolders=($(find "$mainApiPath" -maxdepth 1 -type d ! -path "$mainApiPath"))
                
                if [ ${#nestedFolders[@]} -eq 1 ] && [ -f "${nestedFolders[0]}/host.json" ]; then
                  folderName=$(basename "${nestedFolders[0]}")
                  echo "Found nested folder: $folderName"
                  echo "Extracting files from nested folder to root level..."
                  
                  # Create temp folder for correct structure
                  tempPath="$(Build.ArtifactStagingDirectory)/MainAPI_Fixed"
                  mkdir -p "$tempPath"
                  
                  # Copy all files from nested folder to temp folder
                  cp -r "${nestedFolders[0]}"/* "$tempPath/"
                  
                  # Archive the fixed folder
                  echo "Creating zip from fixed folder structure..."
                  cd "$tempPath"
                  zip -r "$zipFile" .
                  cd - > /dev/null
                  
                  # Cleanup temp folder
                  rm -rf "$tempPath"
                else
                  echo "No nested folder found, archiving as-is..."
                  cd "$mainApiPath"
                  zip -r "$zipFile" .
                  cd - > /dev/null
                fi
                
                echo "✅ Main API zip created: $zipFile"

          - task: PublishBuildArtifacts@1
            displayName: 'Publish Main API Artifact'
            inputs:
              pathtoPublish: '$(Build.ArtifactStagingDirectory)/lacc-main-api-$(Build.BuildId).zip'
              artifactName: 'lacc-main-api-drop'

      - job: Build_FileTransfer_API
        displayName: 'LACC - Build FileTransfer API Function App'
        dependsOn: Build_Solution
        pool:
          vmImage: ubuntu-latest
        steps:
          - task: UseDotNet@2
            displayName: 'Use .NET SDK'
            inputs:
              packageType: 'sdk'
              version: $(dotNetVersion)

          - task: DotNetCoreCLI@2
            displayName: 'Restore FileTransfer API'
            inputs:
              command: 'restore'
              projects: 'backend/CPS.ComplexCases.FileTransfer.API/CPS.ComplexCases.FileTransfer.API.csproj'

          - task: DotNetCoreCLI@2
            displayName: 'Build FileTransfer API'
            inputs:
              command: 'build'
              projects: 'backend/CPS.ComplexCases.FileTransfer.API/CPS.ComplexCases.FileTransfer.API.csproj'
              arguments: '--configuration $(buildConfiguration)'

          - task: DotNetCoreCLI@2
            displayName: 'Publish FileTransfer API'
            inputs:
              command: 'publish'
              projects: 'backend/CPS.ComplexCases.FileTransfer.API/CPS.ComplexCases.FileTransfer.API.csproj'
              publishWebProjects: false
              zipAfterPublish: false
              arguments: '--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)/FileTransferAPI --no-restore /p:SourceRevisionId=$(Build.SourceVersion) /p:PublishUrl=$(Build.ArtifactStagingDirectory)/FileTransferAPI'

          - task: Bash@3
            displayName: 'Debug - List FileTransfer API Output Structure'
            inputs:
              targetType: 'inline'
              script: |
                echo "Checking FileTransfer API output structure:"
                echo "Contents of $(Build.ArtifactStagingDirectory)/FileTransferAPI:"
                find "$(Build.ArtifactStagingDirectory)/FileTransferAPI" -type f | sed "s|$(Build.ArtifactStagingDirectory)/FileTransferAPI||" | head -20

          - task: Bash@3
            displayName: 'Fix FileTransfer API Folder Structure and Archive'
            inputs:
              targetType: 'inline'
              script: |
                fileTransferApiPath="$(Build.ArtifactStagingDirectory)/FileTransferAPI"
                zipFile="$(Build.ArtifactStagingDirectory)/lacc-filetransfer-api-$(Build.BuildId).zip"
                
                echo "Checking for nested folder structure..."
                
                # Check if there's a nested project folder (common with .NET publish)
                nestedFolders=($(find "$fileTransferApiPath" -maxdepth 1 -type d ! -path "$fileTransferApiPath"))
                
                if [ ${#nestedFolders[@]} -eq 1 ] && [ -f "${nestedFolders[0]}/host.json" ]; then
                  folderName=$(basename "${nestedFolders[0]}")
                  echo "Found nested folder: $folderName"
                  echo "Extracting files from nested folder to root level..."
                  
                  # Create temp folder for correct structure
                  tempPath="$(Build.ArtifactStagingDirectory)/FileTransferAPI_Fixed"
                  mkdir -p "$tempPath"
                  
                  # Copy all files from nested folder to temp folder
                  cp -r "${nestedFolders[0]}"/* "$tempPath/"
                  
                  # Archive the fixed folder
                  echo "Creating zip from fixed folder structure..."
                  cd "$tempPath"
                  zip -r "$zipFile" .
                  cd - > /dev/null
                  
                  # Cleanup temp folder
                  rm -rf "$tempPath"
                else
                  echo "No nested folder found, archiving as-is..."
                  cd "$fileTransferApiPath"
                  zip -r "$zipFile" .
                  cd - > /dev/null
                fi
                
                echo "✅ FileTransfer API zip created: $zipFile"

          - task: Bash@3
            displayName: 'Verify Zip Contents'
            inputs:
              targetType: 'inline'
              script: |
                echo "🔍 Verifying zip file contents..."
                
                # Check Main API zip
                mainApiZip="$(Build.ArtifactStagingDirectory)/lacc-main-api-$(Build.BuildId).zip"
                if [ -f "$mainApiZip" ]; then
                  echo ""
                  echo "📦 Main API Zip Contents:"
                  unzip -l "$mainApiZip" | head -20 | tail -n +4 | head -n -2 | sed 's/^/  /'
                  
                  totalFiles=$(unzip -l "$mainApiZip" | tail -n 2 | head -n 1 | awk '{print $2}')
                  if [ "$totalFiles" -gt 10 ]; then
                    echo "  ... and $((totalFiles - 10)) more files"
                  fi
                  
                  # Check if host.json is at root level (not nested)
                  if unzip -l "$mainApiZip" | grep -q "^.*host\.json$"; then
                    echo "  ✅ host.json found at root level - structure is correct!"
                  else
                    echo "  ⚠️ host.json not found at root level - may still be nested"
                  fi
                fi
                
                # Check FileTransfer API zip
                fileTransferZip="$(Build.ArtifactStagingDirectory)/lacc-filetransfer-api-$(Build.BuildId).zip"
                if [ -f "$fileTransferZip" ]; then
                  echo ""
                  echo "📦 FileTransfer API Zip Contents:"
                  unzip -l "$fileTransferZip" | head -20 | tail -n +4 | head -n -2 | sed 's/^/  /'
                  
                  totalFiles=$(unzip -l "$fileTransferZip" | tail -n 2 | head -n 1 | awk '{print $2}')
                  if [ "$totalFiles" -gt 10 ]; then
                    echo "  ... and $((totalFiles - 10)) more files"
                  fi
                  
                  # Check if host.json is at root level (not nested)
                  if unzip -l "$fileTransferZip" | grep -q "^.*host\.json$"; then
                    echo "  ✅ host.json found at root level - structure is correct!"
                  else
                    echo "  ⚠️ host.json not found at root level - may still be nested"
                  fi
                fi

          - task: PublishBuildArtifacts@1
            displayName: 'Publish FileTransfer API Artifact'
            inputs:
              pathtoPublish: '$(Build.ArtifactStagingDirectory)/lacc-filetransfer-api-$(Build.BuildId).zip'
              artifactName: 'lacc-filetransfer-api-drop'

      - job: Package_Database_Scripts
        displayName: 'LACC - Package Database Migration Scripts'
        dependsOn: Build_Solution
        pool:
          vmImage: ubuntu-latest
        steps:
          - task: UseDotNet@2
            displayName: 'Use .NET SDK'
            inputs:
              packageType: 'sdk'
              version: $(dotNetVersion)

          - task: DotNetCoreCLI@2
            displayName: 'Install EF Core Tools'
            inputs:
              command: 'custom'
              custom: 'tool'
              arguments: 'install --global dotnet-ef'

          - task: DotNetCoreCLI@2
            displayName: 'Generate Migration Scripts'
            inputs:
              command: 'custom'
              custom: 'ef'
              arguments: 'migrations script --output $(Build.ArtifactStagingDirectory)/migration-script.sql --project backend/CPS.ComplexCases.Data/CPS.ComplexCases.Data.csproj --startup-project backend/CPS.ComplexCases.API/CPS.ComplexCases.API.csproj'

          - task: CopyFiles@2
            displayName: 'Copy Migration Files'
            inputs:
              sourceFolder: 'backend/CPS.ComplexCases.Data/Migrations'
              contents: '**'
              targetFolder: '$(Build.ArtifactStagingDirectory)/migrations'

          - task: ArchiveFiles@2
            displayName: 'Archive Database Scripts'
            inputs:
              rootFolderOrFile: '$(Build.ArtifactStagingDirectory)'
              includeRootFolder: false
              archiveType: 'zip'
              archiveFile: '$(Build.ArtifactStagingDirectory)/database-scripts-$(Build.BuildId).zip'
              replaceExistingArchive: true
              excludeRootFolder: true

          - task: PublishBuildArtifacts@1
            displayName: 'Publish Database Scripts Artifact'
            inputs:
              pathtoPublish: '$(Build.ArtifactStagingDirectory)/database-scripts-$(Build.BuildId).zip'
              artifactName: 'database-scripts-drop' 