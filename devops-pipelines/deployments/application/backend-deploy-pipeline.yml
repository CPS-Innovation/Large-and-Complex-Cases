trigger: none

resources:
  pipelines:
    - pipeline: BackendBuild
      source: 'LACC Backend - Build, Test & Package'
      trigger:
        branches:
          include:
            - main
            - HA/devops-stuff

parameters:
  - name: environment
    displayName: 'Target Environment'
    type: string
    default: 'dev'
    values:
      - dev
      - qa
      - prod
  - name: runDatabaseMigration
    displayName: 'Run Database Migration'
    type: boolean
    default: true
  - name: deployMainAPI
    displayName: 'Deploy Main API'
    type: boolean
    default: true
  - name: deployFileTransferAPI
    displayName: 'Deploy FileTransfer API'
    type: boolean
    default: true

variables:
  - group: lacc-backend-global-variables
  - group: lacc-backend-secrets-${{ lower(parameters.environment) }}-variables
  - group: lacc-backend-config-${{ lower(parameters.environment) }}-variables
  - name: environmentSuffix
    value: ${{ lower(parameters.environment) }}
  - name: resourceGroupName
    value: 'rg-lacc-$(environmentSuffix)-temp'
  - name: mainApiName
    value: 'func-lacc-api-$(environmentSuffix)-temp'
  - name: fileTransferApiName
    value: 'func-lacc-filetransfer-api-$(environmentSuffix)-temp'
  - name: keyVaultName
    value: 'kv-lacc-$(environmentSuffix)-temp'
  - name: azureSubscription
    ${{ if eq(parameters.environment, 'dev') }}:
      value: 'Azure Pipeline: Large and Complex Cases - Pre-Prod'
    ${{ if eq(parameters.environment, 'qa') }}:
      value: 'Azure Pipeline: Large and Complex Cases - Pre-Prod'
    ${{ if eq(parameters.environment, 'prod') }}:
      value: 'Azure Pipeline: Large and Complex Cases - Prod'

stages:
  - stage: Pre_Deployment_Validation
    displayName: 'LACC - Pre-Deployment Validation'
    jobs:
      - job: Validate_Environment
        displayName: 'LACC - Validate Target Environment'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: Bash@3
            displayName: 'Install Azure CLI'
            inputs:
              targetType: 'inline'
              script: |
                echo "Checking if Azure CLI is installed..."
                
                # Check if az command exists
                if command -v az &> /dev/null; then
                  echo "✅ Azure CLI is already installed"
                  az --version
                  exit 0
                fi
                
                echo "Azure CLI not found, installing..."
                
                # Detect OS and install accordingly
                if [[ "$OSTYPE" == "linux-gnu"* ]]; then
                  echo "Installing Azure CLI on Linux..."
                  
                  # Update package list
                  sudo apt-get update -y
                  
                  # Install prerequisites
                  sudo apt-get install -y ca-certificates curl apt-transport-https lsb-release gnupg
                  
                  # Add Microsoft signing key
                  curl -sL https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/microsoft.gpg > /dev/null
                  
                  # Add Azure CLI repository
                  AZ_REPO=$(lsb_release -cs)
                  echo "deb [arch=amd64] https://packages.microsoft.com/repos/azure-cli/ $AZ_REPO main" | sudo tee /etc/apt/sources.list.d/azure-cli.list
                  
                  # Update package list and install Azure CLI
                  sudo apt-get update -y
                  sudo apt-get install -y azure-cli
                  
                elif [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "cygwin" ]] || [[ "$AGENT_OS" == "Windows_NT" ]]; then
                  echo "Installing Azure CLI on Windows..."
                  
                  # Use PowerShell to download and install
                  powershell.exe -Command "
                    \$ProgressPreference = 'SilentlyContinue'
                    Write-Host 'Downloading Azure CLI installer...'
                    Invoke-WebRequest -Uri 'https://aka.ms/installazurecliwindows' -OutFile 'AzureCLI.msi'
                    Write-Host 'Installing Azure CLI...'
                    Start-Process msiexec.exe -Wait -ArgumentList '/I AzureCLI.msi /quiet /norestart'
                    Remove-Item 'AzureCLI.msi' -Force -ErrorAction SilentlyContinue
                    Write-Host 'Azure CLI installation completed'
                  "
                  
                  # Add to PATH for current session
                  export PATH="$PATH:/c/Program Files (x86)/Microsoft SDKs/Azure/CLI2/wbin"
                  
                else
                  echo "❌ Unsupported operating system: $OSTYPE"
                  exit 1
                fi
                
                # Verify installation
                echo "Verifying Azure CLI installation..."
                if command -v az &> /dev/null; then
                  echo "✅ Azure CLI installation verified"
                  az --version
                else
                  echo "❌ Azure CLI installation verification failed"
                  echo "PATH: $PATH"
                  exit 1
                fi

          - task: AzureCLI@2
            displayName: 'Setup Key Vault Access for Pipeline'
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Setting up Key Vault access for Azure DevOps pipeline..."
                
                # Method 1: Try to get service principal from current context
                CURRENT_USER=$(az account show --query user.name -o tsv)
                echo "Current authenticated user/principal: $CURRENT_USER"
                
                # Method 2: Get the service principal object ID from the service connection
                # This works when using service principal authentication
                SP_OBJECT_ID=""
                
                # Try to get service principal details
                if [[ "$CURRENT_USER" != *"@"* ]]; then
                  # This looks like a service principal ID, get its object ID
                  SP_OBJECT_ID=$(az ad sp show --id "$CURRENT_USER" --query id -o tsv 2>/dev/null || echo "")
                fi
                
                # Method 3: Alternative approach - get from token
                if [ -z "$SP_OBJECT_ID" ]; then
                  # Try to extract from access token
                  TOKEN_INFO=$(az account get-access-token --query accessToken -o tsv 2>/dev/null || echo "")
                  if [ -n "$TOKEN_INFO" ]; then
                    # Decode token to get object ID (this requires jq)
                    SP_OBJECT_ID=$(echo "$TOKEN_INFO" | cut -d'.' -f2 | base64 -d 2>/dev/null | jq -r '.oid' 2>/dev/null || echo "")
                  fi
                fi
                
                # Method 4: Use the service connection's managed identity if available
                if [ -z "$SP_OBJECT_ID" ]; then
                  echo "Attempting to use service connection managed identity..."
                  # Get the service connection's principal ID
                  SP_OBJECT_ID=$(az ad signed-in-user show --query id -o tsv 2>/dev/null || echo "")
                fi
                
                # Grant Key Vault access if we found the object ID
                if [ -n "$SP_OBJECT_ID" ] && [ "$SP_OBJECT_ID" != "null" ] && [ "$SP_OBJECT_ID" != "" ]; then
                  echo "Service Principal Object ID found: $SP_OBJECT_ID"
                  echo "Granting Key Vault access permissions..."
                  
                  az keyvault set-policy \
                    --name "$(keyVaultName)" \
                    --object-id "$SP_OBJECT_ID" \
                    --secret-permissions get list set \
                    --output table || echo "Warning: Could not set Key Vault policy (may already exist or insufficient permissions)"
                    
                  echo "Key Vault access policy configured successfully"
                else
                  echo "Warning: Could not determine service principal object ID"
                  echo "Key Vault access may need to be configured manually"
                fi
                
                # Configure Key Vault networking for build agent access
                echo "Configuring Key Vault networking for build agent access..."
                echo "Attempting to detect build agent IP (with timeout)..."
                
                # Try multiple IP detection services with short timeouts
                BUILD_AGENT_IP=""
                echo "Trying IP detection services..."
                
                # Method 1: ipify.org with 10-second timeout
                if [ -z "$BUILD_AGENT_IP" ]; then
                  BUILD_AGENT_IP=$(timeout 10 curl -s https://api.ipify.org 2>/dev/null || echo "")
                  if [ -n "$BUILD_AGENT_IP" ]; then
                    echo "IP detected via ipify.org: $BUILD_AGENT_IP"
                  fi
                fi
                
                # Method 2: ipinfo.io with 10-second timeout
                if [ -z "$BUILD_AGENT_IP" ]; then
                  BUILD_AGENT_IP=$(timeout 10 curl -s https://ipinfo.io/ip 2>/dev/null || echo "")
                  if [ -n "$BUILD_AGENT_IP" ]; then
                    echo "IP detected via ipinfo.io: $BUILD_AGENT_IP"
                  fi
                fi
                
                # Method 3: icanhazip.com with 10-second timeout
                if [ -z "$BUILD_AGENT_IP" ]; then
                  BUILD_AGENT_IP=$(timeout 10 curl -s https://icanhazip.com 2>/dev/null || echo "")
                  if [ -n "$BUILD_AGENT_IP" ]; then
                    echo "IP detected via icanhazip.com: $BUILD_AGENT_IP"
                  fi
                fi
                
                # Method 4: Try Azure metadata service (works on Azure VMs)
                if [ -z "$BUILD_AGENT_IP" ]; then
                  BUILD_AGENT_IP=$(timeout 5 curl -s -H "Metadata:true" "http://169.254.169.254/metadata/instance/network/interface/0/ipv4/ipAddress/0/publicIpAddress?api-version=2017-08-01&format=text" 2>/dev/null || echo "")
                  if [ -n "$BUILD_AGENT_IP" ]; then
                    echo "IP detected via Azure metadata: $BUILD_AGENT_IP"
                  fi
                fi
                
                if [ -n "$BUILD_AGENT_IP" ] && [ "$BUILD_AGENT_IP" != "" ]; then
                  echo "✅ Build agent IP detected: $BUILD_AGENT_IP"
                  echo "Adding build agent IP to Key Vault firewall..."
                  
                  az keyvault network-rule add \
                    --name "$(keyVaultName)" \
                    --ip-address "$BUILD_AGENT_IP" \
                    --output table || echo "Warning: Could not add IP to Key Vault firewall (may already exist or firewall disabled)"
                  
                  # Store build agent IP for cleanup later
                  echo "##vso[task.setvariable variable=buildAgentIP]$BUILD_AGENT_IP"
                  
                  # Wait a moment for networking changes to apply
                  echo "Waiting for Key Vault networking changes to apply..."
                  sleep 10
                else
                  echo "⚠️ Could not determine build agent IP address"
                  echo "⚠️ This may be due to network restrictions on build agents"
                  echo "⚠️ If Key Vault access fails, manually configure networking in Azure Portal"
                  echo "⚠️ Or set SKIP_KV_TEST=true to bypass the test"
                fi
                
                # Test Key Vault connectivity with retry logic
                echo "Testing Key Vault connectivity..."
                echo "Note: Azure Key Vault policies can take up to 5 minutes to propagate"
                
                # Retry logic for Key Vault access
                MAX_RETRIES=5
                RETRY_DELAY=30
                RETRY_COUNT=0
                
                # Temporary flag to skip Key Vault test if needed
                SKIP_KV_TEST="${SKIP_KV_TEST:-false}"
                
                if [ "$SKIP_KV_TEST" = "true" ]; then
                  echo "⚠️ Skipping Key Vault access test (SKIP_KV_TEST=true)"
                  echo "⚠️ Ensure Key Vault is properly configured manually"
                else
                  while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                    echo "Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES: Testing Key Vault access..."
                    
                    if az keyvault secret list --vault-name "$(keyVaultName)" -o tsv > /dev/null 2>&1; then
                      echo "✅ Key Vault access confirmed - pipeline can read secrets"
                      break
                    else
                      RETRY_COUNT=$((RETRY_COUNT + 1))
                      if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                        echo "⏳ Key Vault access not ready yet. Waiting $RETRY_DELAY seconds before retry..."
                        echo "This is normal - Azure policies can take time to propagate"
                        sleep $RETRY_DELAY
                      else
                        echo "❌ Key Vault access test failed after $MAX_RETRIES attempts"
                        echo "Possible causes:"
                        echo "1. Key Vault firewall blocking build agent IP"
                        echo "2. Service principal lacks permissions"
                        echo "3. Key Vault network restrictions"
                        echo "4. Policy propagation taking longer than expected"
                        echo ""
                        echo "Manual verification steps:"
                        echo "1. Check Key Vault access policies in Azure Portal"
                        echo "2. Verify service principal permissions"
                        echo "3. Check Key Vault networking/firewall settings"
                        exit 1
                      fi
                    fi
                  done
                fi

          - task: AzureCLI@2
            displayName: 'LACC - Initialize Key Vault Secrets from Variable Groups'
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Initializing Key Vault secrets from Azure DevOps variable groups..."
                echo "🔐 Only storing sensitive secrets in Key Vault"
                
                # Function to safely set Key Vault secret
                set_kv_secret() {
                  local secret_name="$1"
                  local secret_value="$2"
                  local description="$3"
                  
                  if [ -n "$secret_value" ] && [ "$secret_value" != "" ] && [ "$secret_value" != "null" ]; then
                    echo "Setting Key Vault secret: $secret_name"
                    az keyvault secret set \
                      --vault-name "$(keyVaultName)" \
                      --name "$secret_name" \
                      --value "$secret_value" \
                      --description "$description" \
                      --output none
                    
                    if [ $? -eq 0 ]; then
                      echo "✅ Secret '$secret_name' set successfully"
                    else
                      echo "❌ Failed to set secret '$secret_name'"
                    fi
                  else
                    echo "⚠️ Skipping '$secret_name' - value is empty or not provided"
                  fi
                }
                
                echo "📋 Setting storage connection secrets..."
                
                # Azure Storage (for Functions)
                set_kv_secret "AzureWebJobsStorage" "$(AzureWebJobsStorage)" "Azure Storage connection for Functions runtime"
                
                echo "📋 Setting database connection secrets..."
                
                # Database Connection String
                set_kv_secret "ConnectionStrings--CaseManagementDatastoreConnection" "$(CaseManagementDatastoreConnection)" "PostgreSQL database connection string"
                
                echo "📋 Setting external API authentication secrets..."
                
                # Egress API Credentials
                set_kv_secret "EgressOptions--Username" "$(EgressOptionsUsername)" "Egress API username"
                set_kv_secret "EgressOptions--Password" "$(EgressOptionsPassword)" "Egress API password"
                
                # DDEI API Credentials
                set_kv_secret "DDEIOptions--AccessKey" "$(DDEIOptionsAccessKey)" "DDEI API access key"
                
                # NetApp API Credentials
                set_kv_secret "NetAppOptions--AccessKey" "$(NetAppOptionsAccessKey)" "NetApp API access key"
                set_kv_secret "NetAppOptions--SecretKey" "$(NetAppOptionsSecretKey)" "NetApp API secret key"
                
                # File Transfer API Credentials
                set_kv_secret "FileTransferApiOptions--AccessKey" "$(FileTransferApiOptionsAccessKey)" "File Transfer API access key"
                
                echo "✅ Key Vault secret initialization completed"
                echo "📋 Secrets stored in Key Vault:"
                echo "  - AzureWebJobsStorage"
                echo "  - EgressOptions--Username"
                echo "  - EgressOptions--Password"
                echo "  - DDEIOptions--AccessKey"
                echo "  - ConnectionStrings--CaseManagementDatastoreConnection"
                echo "  - NetAppOptions--AccessKey"
                echo "  - NetAppOptions--SecretKey"
                echo "  - FileTransferApiOptions--AccessKey"
                
                # List all secrets that were set (names only, not values)
                echo "📋 Current Key Vault secrets:"
                az keyvault secret list --vault-name "$(keyVaultName)" --query "[].name" -o table
                
                # Verify PostgreSQL connection string was set correctly (SECURELY)
                echo "🔍 Verifying PostgreSQL connection string secret..."
                POSTGRES_SECRET_EXISTS=$(az keyvault secret show --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query "id" -o tsv 2>/dev/null || echo "")
                
                if [ -n "$POSTGRES_SECRET_EXISTS" ]; then
                  echo "✅ PostgreSQL connection string secret exists in Key Vault"
                  
                  # Test if we can retrieve the value WITHOUT storing it in a variable (for security)
                  # We only check if the secret can be retrieved, not store its content
                  if az keyvault secret show --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query value -o tsv >/dev/null 2>&1; then
                    # Get just the length without storing the actual secret
                    SECRET_LENGTH=$(az keyvault secret show --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query value -o tsv 2>/dev/null | wc -c)
                    echo "✅ PostgreSQL connection string value is accessible (length: $SECRET_LENGTH characters)"
                  else
                    echo "❌ PostgreSQL connection string secret exists but value is empty or inaccessible"
                    echo "Check variable group: 'CaseManagementDatastoreConnection' variable"
                  fi
                else
                  echo "❌ PostgreSQL connection string secret was not created in Key Vault"
                  echo "This indicates the variable 'CaseManagementDatastoreConnection' was empty or not provided"
                  echo "Check variable group: lacc-backend-config-${{ lower(parameters.environment) }}-variables"
                fi

          - task: AzureCLI@2
            displayName: 'LACC - Check Resource Group Exists'
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                if ! az group show --name $(resourceGroupName) &> /dev/null; then
                  echo "##vso[task.logissue type=error]Resource group $(resourceGroupName) does not exist"
                  exit 1
                fi
                echo "Resource group $(resourceGroupName) exists"

          - task: AzureCLI@2
            displayName: 'Check Function Apps Exist'
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Check Main API if deployment is enabled
                if [ "${{ parameters.deployMainAPI }}" = "True" ]; then
                  if ! az functionapp show --name $(mainApiName) --resource-group $(resourceGroupName) &> /dev/null; then
                    echo "##vso[task.logissue type=error]Main API Function App $(mainApiName) does not exist"
                    exit 1
                  fi
                  echo "Main API Function App $(mainApiName) exists"
                fi
                
                # Check FileTransfer API if deployment is enabled
                if [ "${{ parameters.deployFileTransferAPI }}" = "True" ]; then
                  if ! az functionapp show --name $(fileTransferApiName) --resource-group $(resourceGroupName) &> /dev/null; then
                    echo "##vso[task.logissue type=error]FileTransfer API Function App $(fileTransferApiName) does not exist"
                    exit 1
                  fi
                  echo "FileTransfer API Function App $(fileTransferApiName) exists"
                fi

  - stage: Database_Migration
    displayName: 'LACC - Database Migration'
    dependsOn: Pre_Deployment_Validation
    condition: and(succeeded(), eq(${{ parameters.runDatabaseMigration }}, true))
    jobs:
      - deployment: Deploy_Database_Changes
        displayName: 'LACC - Deploy Database Changes'
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'LACC-Backend-${{ parameters.environment }}'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: DownloadBuildArtifacts@0
                  displayName: 'Download Database Scripts'
                  inputs:
                    buildType: 'specific'
                    project: '$(System.TeamProjectId)'
                    pipeline: 'LACC Backend - Build, Test & Package'
                    buildVersionToDownload: 'latest'
                    artifactName: 'database-scripts-drop'
                    downloadPath: '$(Pipeline.Workspace)'

                - task: ExtractFiles@1
                  displayName: 'Extract Database Scripts'
                  inputs:
                    archiveFilePatterns: '$(Pipeline.Workspace)/database-scripts-drop/*.zip'
                    destinationFolder: '$(Pipeline.Workspace)/database-scripts'
                    cleanDestinationFolder: true

                - task: AzureCLI@2
                  displayName: 'Temporarily Allow Key Vault Access for Database Migration'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      echo "Temporarily allowing pipeline access to Key Vault for Database Migration..."
                      
                      # Get current pipeline IP for this stage
                      PIPELINE_IP=$(curl -s https://api.ipify.org || curl -s https://ipinfo.io/ip || curl -s https://icanhazip.com)
                      echo "Database Migration Stage IP Address: $PIPELINE_IP"
                      
                      # Add pipeline IP to Key Vault firewall rules
                      az keyvault network-rule add \
                        --name "$(keyVaultName)" \
                        --ip-address "$PIPELINE_IP" \
                        --output table
                      
                      # Wait a moment for the rule to take effect
                      echo "Waiting for firewall rule to take effect..."
                      sleep 10
                      
                      echo "✅ Key Vault access configured for Database Migration IP: $PIPELINE_IP"
                      echo "##vso[task.setvariable variable=dbMigrationIP]$PIPELINE_IP"

                - task: AzureCLI@2
                  displayName: 'Configure PostgreSQL Firewall for Pipeline'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      echo "Configuring PostgreSQL Flexible Server firewall for pipeline access..."
                      
                      # Get the current public IP of the build agent
                      PIPELINE_IP=$(curl -s https://api.ipify.org || curl -s https://ipinfo.io/ip || curl -s https://icanhazip.com)
                      echo "Pipeline IP Address: $PIPELINE_IP"
                      
                      if [ -z "$PIPELINE_IP" ]; then
                        echo "❌ Could not determine pipeline IP address"
                        exit 1
                      fi
                      
                      # Get PostgreSQL connection string and parse components
                      echo "Retrieving connection string from Key Vault: $(keyVaultName)"
                      echo "Secret name: ConnectionStrings--CaseManagementDatastoreConnection"
                      
                      # Check if secret exists and list versions for debugging
                      echo "Checking secret versions..."
                      az keyvault secret list-versions --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query "[].{Version:id, Enabled:attributes.enabled}" -o table || echo "Could not list versions"
                      
                      # SECURITY: Parse host directly without storing full connection string
                      DB_HOST=$(az keyvault secret show --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query value -o tsv 2>/dev/null | grep -oP '(?<=Host=)[^;]+' | head -1)
                      
                      if [ -z "$DB_HOST" ]; then
                        echo "❌ PostgreSQL connection string not found in Key Vault or could not parse host"
                        echo "This could indicate:"
                        echo "1. PostgreSQL connection string not found in Key Vault"
                        echo "2. Connection string format is incorrect"
                        echo "3. Secret is disabled or service principal lacks access"
                        echo "Please ensure ConnectionStrings--CaseManagementDatastoreConnection is set in Key Vault"
                        exit 1
                      fi
                      
                      echo "✅ Connection string parsed successfully, host: $DB_HOST"
                      
                      # Extract server name from hostname (remove .postgres.database.azure.com)
                      DB_SERVER_NAME=$(echo "$DB_HOST" | sed 's/\.postgres\.database\.azure\.com.*//')
                      echo "PostgreSQL Server Name: $DB_SERVER_NAME"
                      
                      # Create firewall rule name with timestamp
                      RULE_NAME="AzureDevOps-Pipeline-$(date +%Y%m%d-%H%M%S)"
                      echo "Creating firewall rule: $RULE_NAME"
                      
                      # Add firewall rule for the pipeline IP
                      az postgres flexible-server firewall-rule create \
                        --resource-group "$(resourceGroupName)" \
                        --name "$DB_SERVER_NAME" \
                        --rule-name "$RULE_NAME" \
                        --start-ip-address "$PIPELINE_IP" \
                        --end-ip-address "$PIPELINE_IP" \
                        --output table
                      
                      if [ $? -eq 0 ]; then
                        echo "✅ Firewall rule created successfully"
                        echo "##vso[task.setvariable variable=firewallRuleName]$RULE_NAME"
                        echo "##vso[task.setvariable variable=pipelineIP]$PIPELINE_IP"
                      else
                        echo "❌ Failed to create firewall rule"
                        exit 1
                      fi

                - task: AzureCLI@2
                  displayName: 'Run Database Migration'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      # Install PostgreSQL client (optimized)
                      echo "Installing PostgreSQL client..."
                      sudo apt-get update -qq
                      sudo apt-get install -y postgresql-client
                      
                      # SECURITY: Disable command echoing to prevent credential exposure
                      set +x
                      
                      # SECURITY: Parse connection string components WITHOUT storing the full secret in variables
                      echo "Retrieving and parsing connection string securely from Key Vault: $(keyVaultName)"
                      
                      # Add retry logic for Key Vault access
                      for attempt in {1..3}; do
                        echo "Key Vault access attempt $attempt..."
                        
                        # Extract components directly from Key Vault command output without storing full connection string
                        DB_HOST=$(az keyvault secret show --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query value -o tsv 2>/dev/null | grep -oP '(?<=Host=)[^;]+' | head -1)
                        DB_NAME=$(az keyvault secret show --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query value -o tsv 2>/dev/null | grep -oP '(?<=Database=)[^;]+' | head -1)
                        DB_USER=$(az keyvault secret show --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query value -o tsv 2>/dev/null | grep -oP '(?<=User Id=)[^;]+' | head -1)
                        DB_PASS=$(az keyvault secret show --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query value -o tsv 2>/dev/null | grep -oP '(?<=Password=)[^;]+' | head -1)
                        
                        # Check if we successfully retrieved all components
                        if [ -n "$DB_HOST" ] && [ -n "$DB_NAME" ] && [ -n "$DB_USER" ] && [ -n "$DB_PASS" ]; then
                          echo "✅ Successfully retrieved connection string components on attempt $attempt"
                          break
                        else
                          if [ $attempt -eq 3 ]; then
                            echo "❌ Failed to retrieve connection string components after 3 attempts"
                          else
                            echo "Key Vault access failed, waiting 10 seconds before retry..."
                            sleep 10
                          fi
                        fi
                      done
                      
                      # Validate that we successfully retrieved and parsed credentials without exposing them
                      if [ -z "$DB_HOST" ]; then
                        echo "❌ Could not parse PostgreSQL host from connection string"
                        echo "This could indicate:"
                        echo "1. PostgreSQL connection string not found in Key Vault"
                        echo "2. Connection string format is incorrect"
                        echo "3. Key Vault access permissions issue"
                        echo "Please ensure ConnectionStrings--CaseManagementDatastoreConnection is set in Key Vault"
                        exit 1
                      fi
                      if [ -z "$DB_NAME" ]; then
                        echo "❌ Could not parse PostgreSQL database name from connection string"
                        exit 1
                      fi
                      if [ -z "$DB_USER" ]; then
                        echo "❌ Could not parse PostgreSQL username from connection string"
                        echo "Expected format: User Id=username (not Username=username)"
                        exit 1
                      fi
                      if [ -z "$DB_PASS" ]; then
                        echo "❌ Could not parse PostgreSQL password from connection string"
                        exit 1
                      fi
                      
                      echo "Testing database connection..."
                      echo "Host: $DB_HOST"
                      echo "Database: $DB_NAME"
                      echo "User: $DB_USER"
                      echo "Password: [REDACTED FOR SECURITY]"
                      
                      # First test server connectivity
                      echo "Testing server connectivity..."
                      PGPASSWORD="$DB_PASS" psql -h "$DB_HOST" -U "$DB_USER" -d "postgres" -c "SELECT 'Server connection successful' as status;" -t
                      
                      if [ $? -ne 0 ]; then
                        echo "❌ Cannot connect to PostgreSQL server"
                        exit 1
                      fi
                      
                      # Then test target database connection with detailed output
                      echo "Testing target database connection..."
                      PGPASSWORD="$DB_PASS" psql -h "$DB_HOST" -U "$DB_USER" -d "$DB_NAME" -c "SELECT 'Database connection successful' as status, version(), current_database(), current_user, inet_server_addr(), inet_server_port();" -t
                        
                        if [ $? -eq 0 ]; then
                        echo "✅ Database connection test passed"
                        
                        # Additional checks
                        echo "Running additional database health checks..."
                        
                        # Check if we can query system tables
                        PGPASSWORD="$DB_PASS" psql -h "$DB_HOST" -U "$DB_USER" -d "$DB_NAME" -c "SELECT count(*) as table_count FROM information_schema.tables WHERE table_schema = 'public';" -t
                        
                        echo "✅ Database health check completed successfully"
                      else
                        echo "❌ Database connection test failed"
                        echo "Please check:"
                        echo "1. PostgreSQL server is running and accessible"
                        echo "2. Firewall rules are configured correctly"
                        echo "3. Connection credentials are correct"
                        echo "4. Network connectivity is available"
                        exit 1
                      fi

                - task: AzureCLI@2
                  displayName: 'Cleanup PostgreSQL Firewall Rule'
                  condition: always()
                  inputs:
                    azureSubscription: $(azureSubscription)
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      echo "Cleaning up temporary firewall rule..."
                      
                      # Get variables from previous step
                      RULE_NAME="$(firewallRuleName)"
                      PIPELINE_IP="$(pipelineIP)"
                      
                      if [ -n "$RULE_NAME" ]; then
                        # SECURITY: Get PostgreSQL server details without storing full connection string
                        DB_HOST=$(az keyvault secret show --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query value -o tsv 2>/dev/null | grep -oP '(?<=Host=)[^;]+' | head -1)
                        DB_SERVER_NAME=$(echo "$DB_HOST" | sed 's/\.postgres\.database\.azure\.com.*//')
                        
                        echo "Removing firewall rule: $RULE_NAME"
                        echo "From PostgreSQL server: $DB_SERVER_NAME"
                        echo "Pipeline IP was: $PIPELINE_IP"
                        
                        # Remove the temporary firewall rule
                        az postgres flexible-server firewall-rule delete \
                          --resource-group "$(resourceGroupName)" \
                          --name "$DB_SERVER_NAME" \
                          --rule-name "$RULE_NAME" \
                          --yes \
                          --output table || echo "Warning: Could not remove firewall rule (may not exist)"
                        
                        echo "✅ Firewall rule cleanup completed"
                      else
                        echo "No firewall rule to clean up"
                      fi

                - task: AzureCLI@2
                  displayName: 'Cleanup Key Vault Access for Database Migration'
                  condition: always()
                  inputs:
                    azureSubscription: $(azureSubscription)
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      echo "Cleaning up Key Vault firewall rule for Database Migration stage..."
                      
                      # Get this stage's IP
                      DB_MIGRATION_IP="$(dbMigrationIP)"
                      
                      if [ -n "$DB_MIGRATION_IP" ]; then
                        echo "Removing Database Migration IP from Key Vault firewall: $DB_MIGRATION_IP"
                        
                        # Remove this stage's IP from Key Vault firewall rules
                        az keyvault network-rule remove \
                          --name "$(keyVaultName)" \
                          --ip-address "$DB_MIGRATION_IP" \
                          --output table || echo "Warning: Could not remove Key Vault firewall rule for Database Migration"
                        
                        echo "✅ Database Migration Key Vault firewall rule cleanup completed"
                      else
                        echo "No Database Migration Key Vault firewall rule to clean up"
                      fi



  - stage: Deploy_Function_Apps
    displayName: 'LACC - Deploy Function Apps'
    ${{ if eq(parameters.runDatabaseMigration, true) }}:
      dependsOn: 
        - Pre_Deployment_Validation
        - Database_Migration
    ${{ else }}:
      dependsOn: Pre_Deployment_Validation
    condition: |
      and(
        succeeded('Pre_Deployment_Validation'),
        or(
          and(eq(${{ parameters.runDatabaseMigration }}, true), succeeded('Database_Migration')),
          eq(${{ parameters.runDatabaseMigration }}, false)
        )
      )
    jobs:
      - deployment: Deploy_Main_API
        displayName: 'LACC - Deploy Main API Function App'
        condition: eq(${{ parameters.deployMainAPI }}, true)
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'LACC-Backend-${{ parameters.environment }}'
        strategy:
          runOnce:
            deploy:
              steps:


                - task: DownloadBuildArtifacts@0
                  displayName: 'LACC - Download Main API Artifact'
                  inputs:
                    buildType: 'specific'
                    project: '$(System.TeamProjectId)'
                    pipeline: 'LACC Backend - Build, Test & Package'
                    buildVersionToDownload: 'latest'
                    artifactName: 'lacc-main-api-drop'
                    downloadPath: '$(Pipeline.Workspace)'

                - template: ../templates/configuration-template.yml
                  parameters:
                    environment: ${{ parameters.environment }}
                    functionAppName: $(mainApiName)
                    subscriptionName: $(azureSubscription)
                    resourceGroupName: $(resourceGroupName)
                    keyVaultName: $(keyVaultName)
                    appInsightsKey: $(ApplicationInsightsInstrumentationKey)
                    appInsightsConnectionString: $(ApplicationInsightsConnectionString)

                - task: AzureFunctionApp@2
                  displayName: 'LACC - Deploy Main API to Azure Function App'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    appType: 'functionApp'
                    appName: $(mainApiName)
                    package: '$(Pipeline.Workspace)/lacc-main-api-drop/*.zip'
                    runtimeStack: 'DOTNET-ISOLATED|8.0'
                    deploymentMethod: 'runFromPackage'

                - task: AzureCLI@2
                  displayName: 'LACC - Verify Main API Deployment'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      echo "Verifying Main API deployment..."
                      
                      # Check if deployment completed successfully
                      DEPLOYMENT_STATUS=$(az functionapp deployment list --name $(mainApiName) --resource-group $(resourceGroupName) --query "[0].status" -o tsv)
                      echo "Latest deployment status: $DEPLOYMENT_STATUS"
                      
                      # Wait a moment for extraction to complete
                      echo "Waiting for deployment to stabilize..."
                      sleep 10
                      
                      # Check if function app is running
                      APP_STATE=$(az functionapp show --name $(mainApiName) --resource-group $(resourceGroupName) --query "state" -o tsv)
                      echo "Function app state: $APP_STATE"
                      
                      if [ "$APP_STATE" != "Running" ]; then
                        echo "⚠️ Function app is not in Running state"
                      else
                        echo "✅ Function app is running"
                      fi



      - deployment: Deploy_FileTransfer_API
        displayName: 'LACC - Deploy FileTransfer API Function App'
        condition: eq(${{ parameters.deployFileTransferAPI }}, true)
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'LACC-Backend-${{ parameters.environment }}'
        strategy:
          runOnce:
            deploy:
              steps:


                - task: DownloadBuildArtifacts@0
                  displayName: 'LACC - Download FileTransfer API Artifact'
                  inputs:
                    buildType: 'specific'
                    project: '$(System.TeamProjectId)'
                    pipeline: 'LACC Backend - Build, Test & Package'
                    buildVersionToDownload: 'latest'
                    artifactName: 'lacc-filetransfer-api-drop'
                    downloadPath: '$(Pipeline.Workspace)'

                - template: ../templates/configuration-template.yml
                  parameters:
                    environment: ${{ parameters.environment }}
                    functionAppName: $(fileTransferApiName)
                    subscriptionName: $(azureSubscription)
                    resourceGroupName: $(resourceGroupName)
                    keyVaultName: $(keyVaultName)
                    appInsightsKey: $(ApplicationInsightsInstrumentationKey)
                    appInsightsConnectionString: $(ApplicationInsightsConnectionString)

                - task: AzureFunctionApp@2
                  displayName: 'LACC - Deploy FileTransfer API to Azure Function App'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    appType: 'functionApp'
                    appName: $(fileTransferApiName)
                    package: '$(Pipeline.Workspace)/lacc-filetransfer-api-drop/*.zip'
                    runtimeStack: 'DOTNET-ISOLATED|8.0'
                    deploymentMethod: 'runFromPackage'

                - task: AzureCLI@2
                  displayName: 'LACC - Verify FileTransfer API Deployment'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      echo "Verifying FileTransfer API deployment..."
                      
                      # Check if deployment completed successfully
                      DEPLOYMENT_STATUS=$(az functionapp deployment list --name $(fileTransferApiName) --resource-group $(resourceGroupName) --query "[0].status" -o tsv)
                      echo "Latest deployment status: $DEPLOYMENT_STATUS"
                      
                      # Wait a moment for extraction to complete
                      echo "Waiting for deployment to stabilize..."
                      sleep 10
                      
                      # Check if function app is running
                      APP_STATE=$(az functionapp show --name $(fileTransferApiName) --resource-group $(resourceGroupName) --query "state" -o tsv)
                      echo "Function app state: $APP_STATE"
                      
                      if [ "$APP_STATE" != "Running" ]; then
                        echo "⚠️ Function app is not in Running state"
                      else
                        echo "✅ Function app is running"
                      fi



  - stage: Post_Deployment_Validation
    displayName: 'LACC - Post-Deployment Validation'
    dependsOn: Deploy_Function_Apps
    jobs:
      - job: Health_Check
        displayName: 'LACC - Health Check Function Apps'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: AzureCLI@2
            displayName: 'LACC - Setup Key Vault Access for Post-Deployment Validation'
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Setting up Key Vault access for Post-Deployment Validation stage..."
                
                # Get current pipeline IP for this specific stage/agent
                PIPELINE_IP=$(curl -s https://api.ipify.org || curl -s https://ipinfo.io/ip || curl -s https://icanhazip.com)
                echo "Post-Deployment Validation Stage IP Address: $PIPELINE_IP"
                
                if [ -z "$PIPELINE_IP" ]; then
                  echo "❌ Could not determine pipeline IP address"
                  exit 1
                fi
                
                echo "Adding pipeline IP to Key Vault firewall for this stage..."
                az keyvault network-rule add \
                  --name "$(keyVaultName)" \
                  --ip-address "$PIPELINE_IP" \
                  --output table || echo "Warning: Could not add Key Vault firewall rule (may already exist)"
                
                # Wait for the rule to take effect and verify access with extended retry
                echo "Waiting for Key Vault firewall rule to take effect..."
                sleep 30
                
                # Test Key Vault access with extended retry logic
                echo "Testing Key Vault access with extended retry logic..."
                SUCCESS=false
                for i in {1..8}; do
                  echo "Access test attempt $i/8..."
                  
                  if az keyvault secret list --vault-name "$(keyVaultName)" --query "[0].name" -o tsv >/dev/null 2>&1; then
                    echo "✅ Key Vault access confirmed on attempt $i"
                    SUCCESS=true
                    break
                  else
                    echo "Access test failed, waiting 20 more seconds for propagation..."
                    sleep 20
                  fi
                done
                
                if [ "$SUCCESS" = false ]; then
                  echo "❌ Key Vault access still not working after extended retry"
                  echo "Current IP: $PIPELINE_IP"
                  echo "Key Vault: $(keyVaultName)"
                  echo ""
                  echo "Debugging information:"
                  echo "1. Checking if Key Vault exists..."
                  az keyvault show --name "$(keyVaultName)" --query "name" -o tsv || echo "Key Vault not found or no access"
                  
                  echo "2. Checking current network rules..."
                  az keyvault network-rule list --name "$(keyVaultName)" --query "ipRules[].value" -o table || echo "Cannot access network rules"
                  
                  echo "3. This may cause issues with database connection tests and secret retrieval"
                  echo "4. Continuing with deployment but some validation steps may fail..."
                else
                  echo "✅ Key Vault access successfully configured for Post-Deployment Validation"
                fi
                
                # Store the IP for cleanup later
                echo "##vso[task.setvariable variable=postDeploymentValidationIP]$PIPELINE_IP"

          - task: AzureCLI@2
            displayName: 'LACC - Whitelist Function App Outbound IPs to Key Vault'
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Configuring Key Vault firewall to allow Function App outbound IPs..."
                
                # Function to add IP addresses to Key Vault firewall
                add_function_ips_to_keyvault() {
                  local function_name="$1"
                  local display_name="$2"
                  
                  echo "Processing $display_name ($function_name)..."
                  
                  # Check if function app exists
                  if ! az functionapp show --name "$function_name" --resource-group "$(resourceGroupName)" &> /dev/null; then
                    echo "⚠️ Function App $function_name not found or not deployed, skipping..."
                    return 0
                  fi
                  
                  # Get outbound IP addresses
                  echo "Getting outbound IP addresses for $function_name..."
                  OUTBOUND_IPS=$(az functionapp show --name "$function_name" --resource-group "$(resourceGroupName)" --query "outboundIpAddresses" -o tsv)
                  ADDITIONAL_OUTBOUND_IPS=$(az functionapp show --name "$function_name" --resource-group "$(resourceGroupName)" --query "possibleOutboundIpAddresses" -o tsv 2>/dev/null || echo "")
                  
                  if [ -z "$OUTBOUND_IPS" ]; then
                    echo "⚠️ Could not retrieve outbound IPs for $function_name"
                    return 0
                  fi
                  
                  echo "Current outbound IPs for $function_name: $OUTBOUND_IPS"
                  if [ -n "$ADDITIONAL_OUTBOUND_IPS" ]; then
                    echo "Possible outbound IPs for $function_name: $ADDITIONAL_OUTBOUND_IPS"
                    # Combine both sets and remove duplicates
                    ALL_IPS=$(echo "$OUTBOUND_IPS,$ADDITIONAL_OUTBOUND_IPS" | tr ',' '\n' | sort | uniq | tr '\n' ',' | sed 's/,$//')
                  else
                    ALL_IPS="$OUTBOUND_IPS"
                  fi
                  
                  # Add each IP to Key Vault firewall
                  IFS=',' read -ra IP_ARRAY <<< "$ALL_IPS"
                  for ip in "${IP_ARRAY[@]}"; do
                    if [ -n "$ip" ] && [ "$ip" != "" ]; then
                      echo "Adding IP $ip to Key Vault firewall for $display_name..."
                      az keyvault network-rule add \
                        --name "$(keyVaultName)" \
                        --ip-address "$ip" \
                        --output none || echo "Warning: Could not add IP $ip (may already exist)"
                    fi
                  done
                  
                  echo "✅ Completed IP whitelisting for $display_name"
                }
                
                # Add IPs for Main API if deployed
                if [ "${{ parameters.deployMainAPI }}" = "True" ]; then
                  add_function_ips_to_keyvault "$(mainApiName)" "Main API"
                fi
                
                # Add IPs for FileTransfer API if deployed
                if [ "${{ parameters.deployFileTransferAPI }}" = "True" ]; then
                  add_function_ips_to_keyvault "$(fileTransferApiName)" "FileTransfer API"
                fi
                
                echo "✅ Function App IP whitelisting to Key Vault completed"
                echo "Waiting for Key Vault network rules to propagate..."
                sleep 30

          - task: AzureCLI@2
            displayName: 'LACC - Configure Inter-Function App Communication'
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Configuring inter-Function App communication access restrictions..."
                echo "Main API needs to communicate with FileTransfer API"
                
                # Only proceed if both Function Apps are deployed
                if [ "${{ parameters.deployMainAPI }}" = "True" ] && [ "${{ parameters.deployFileTransferAPI }}" = "True" ]; then
                  echo "Both Main API and FileTransfer API are deployed, configuring inter-app communication..."
                  
                  # Check if both function apps exist
                  if ! az functionapp show --name "$(mainApiName)" --resource-group "$(resourceGroupName)" &> /dev/null; then
                    echo "⚠️ Main API Function App $(mainApiName) not found, skipping inter-app communication setup..."
                    exit 0
                  fi
                  
                  if ! az functionapp show --name "$(fileTransferApiName)" --resource-group "$(resourceGroupName)" &> /dev/null; then
                    echo "⚠️ FileTransfer API Function App $(fileTransferApiName) not found, skipping inter-app communication setup..."
                    exit 0
                  fi
                  
                  echo "Getting Main API outbound IP addresses..."
                  
                  # Get Main API outbound IP addresses
                  MAIN_API_OUTBOUND_IPS=$(az functionapp show --name "$(mainApiName)" --resource-group "$(resourceGroupName)" --query "outboundIpAddresses" -o tsv)
                  MAIN_API_ADDITIONAL_OUTBOUND_IPS=$(az functionapp show --name "$(mainApiName)" --resource-group "$(resourceGroupName)" --query "possibleOutboundIpAddresses" -o tsv 2>/dev/null || echo "")
                  
                  if [ -z "$MAIN_API_OUTBOUND_IPS" ]; then
                    echo "❌ Could not retrieve Main API outbound IPs"
                    exit 1
                  fi
                  
                  echo "Main API current outbound IPs: $MAIN_API_OUTBOUND_IPS"
                  if [ -n "$MAIN_API_ADDITIONAL_OUTBOUND_IPS" ]; then
                    echo "Main API possible outbound IPs: $MAIN_API_ADDITIONAL_OUTBOUND_IPS"
                    # Combine both sets and remove duplicates
                    ALL_MAIN_API_IPS=$(echo "$MAIN_API_OUTBOUND_IPS,$MAIN_API_ADDITIONAL_OUTBOUND_IPS" | tr ',' '\n' | sort | uniq | tr '\n' ',' | sed 's/,$//')
                  else
                    ALL_MAIN_API_IPS="$MAIN_API_OUTBOUND_IPS"
                  fi
                  
                  echo "Adding Main API outbound IPs to FileTransfer API access restrictions..."
                  
                  # Add each Main API IP to FileTransfer API access restrictions
                  IFS=',' read -ra IP_ARRAY <<< "$ALL_MAIN_API_IPS"
                  RULE_COUNTER=1
                  
                  for ip in "${IP_ARRAY[@]}"; do
                    if [ -n "$ip" ] && [ "$ip" != "" ]; then
                      # Create unique rule name for Main API communication
                      RULE_NAME="MainAPI-Communication-$(echo $ip | tr '.' '-')"
                      
                      # Truncate rule name if too long (Azure limit is 80 characters)
                      if [ ${#RULE_NAME} -gt 78 ]; then
                        RULE_NAME="MainAPI-$(echo $ip | tr '.' '-' | cut -c1-20)"
                      fi
                      
                      echo "Adding Main API IP $ip to FileTransfer API with rule: $RULE_NAME"
                      
                      # Add access restriction rule with priority 200 (lower than pipeline health checks at 100)
                      az functionapp config access-restriction add \
                        --resource-group "$(resourceGroupName)" \
                        --name "$(fileTransferApiName)" \
                        --rule-name "$RULE_NAME" \
                        --action Allow \
                        --ip-address "$ip" \
                        --priority $((200 + RULE_COUNTER)) \
                        --output table || echo "Warning: Could not add access restriction for Main API IP $ip (may already exist)"
                      
                      if [ $? -eq 0 ]; then
                        echo "✅ Successfully added Main API IP $ip to FileTransfer API access restrictions"
                      else
                        echo "❌ Failed to add Main API IP $ip to FileTransfer API access restrictions"
                      fi
                      
                      RULE_COUNTER=$((RULE_COUNTER + 1))
                    fi
                  done
                  
                  echo "✅ Inter-Function App communication configuration completed"
                  echo "Main API ($(mainApiName)) can now communicate with FileTransfer API ($(fileTransferApiName))"
                  
                else
                  echo "ℹ️ Skipping inter-Function App communication setup:"
                  echo "  - Deploy Main API: ${{ parameters.deployMainAPI }}"
                  echo "  - Deploy FileTransfer API: ${{ parameters.deployFileTransferAPI }}"
                  echo "Both Function Apps must be deployed for inter-app communication setup"
                fi
                
                # Now whitelist Function App IPs to PostgreSQL Flexible Server
                echo "Configuring PostgreSQL Flexible Server firewall for Function App outbound IPs..."
                
                # Debug: Check if the secret exists in Key Vault
                echo "🔍 Debugging Key Vault secrets..."
                echo "Key Vault Name: $(keyVaultName)"
                echo "Expected Secret Name: ConnectionStrings--CaseManagementDatastoreConnection"
                
                # List all secrets to see what's available (with retry for network propagation)
                echo "📋 Available secrets in Key Vault:"
                for i in {1..3}; do
                  if az keyvault secret list --vault-name "$(keyVaultName)" --query "[].name" -o table; then
                    break
                  else
                    echo "Attempt $i failed, waiting for Key Vault network rules to propagate..."
                    sleep 10
                  fi
                done
                
                # Check if the specific secret exists
                echo "🔍 Checking if PostgreSQL connection string secret exists..."
                SECRET_EXISTS=$(az keyvault secret show --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query "id" -o tsv 2>/dev/null || echo "")
                
                if [ -n "$SECRET_EXISTS" ]; then
                  echo "✅ Secret exists, attempting to retrieve and parse components securely..."
                  
                  # SECURITY: Parse connection string components WITHOUT storing the full secret in variables
                  # Extract only the specific components we need directly from the command output
                  DB_HOST=$(az keyvault secret show --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query value -o tsv 2>/dev/null | grep -oP '(?<=Host=)[^;]+' | head -1)
                  
                  if [ -z "$DB_HOST" ]; then
                    echo "❌ Could not parse PostgreSQL host from connection string or connection string is empty"
                    echo "Skipping PostgreSQL firewall configuration for Function Apps"
                    echo "⚠️ Function Apps may not be able to connect to PostgreSQL without manual firewall configuration"
                  else
                    echo "✅ Successfully parsed database host: $DB_HOST"
                    
                    # Extract server name from hostname (remove .postgres.database.azure.com)
                    DB_SERVER_NAME=$(echo "$DB_HOST" | sed 's/\.postgres\.database\.azure\.com.*//')
                    echo "PostgreSQL Server Name: $DB_SERVER_NAME"
                    
                    # Function to add Function App IPs to PostgreSQL firewall
                    add_function_ips_to_postgres() {
                      local function_name="$1"
                      local display_name="$2"
                      
                      echo "Adding $display_name outbound IPs to PostgreSQL firewall..."
                      
                      # Check if function app exists
                      if ! az functionapp show --name "$function_name" --resource-group "$(resourceGroupName)" &> /dev/null; then
                        echo "⚠️ Function App $function_name not found, skipping PostgreSQL firewall config..."
                        return 0
                      fi
                      
                      # Get outbound IP addresses
                      OUTBOUND_IPS=$(az functionapp show --name "$function_name" --resource-group "$(resourceGroupName)" --query "outboundIpAddresses" -o tsv)
                      ADDITIONAL_OUTBOUND_IPS=$(az functionapp show --name "$function_name" --resource-group "$(resourceGroupName)" --query "possibleOutboundIpAddresses" -o tsv 2>/dev/null || echo "")
                      
                      if [ -z "$OUTBOUND_IPS" ]; then
                        echo "⚠️ Could not retrieve outbound IPs for $function_name"
                        return 0
                      fi
                      
                      # Combine both sets and remove duplicates
                      if [ -n "$ADDITIONAL_OUTBOUND_IPS" ]; then
                        ALL_IPS=$(echo "$OUTBOUND_IPS,$ADDITIONAL_OUTBOUND_IPS" | tr ',' '\n' | sort | uniq | tr '\n' ',' | sed 's/,$//')
                      else
                        ALL_IPS="$OUTBOUND_IPS"
                      fi
                      
                      # Add each IP to PostgreSQL firewall
                      IFS=',' read -ra IP_ARRAY <<< "$ALL_IPS"
                      for ip in "${IP_ARRAY[@]}"; do
                        if [ -n "$ip" ] && [ "$ip" != "" ]; then
                          # Create unique rule name with IP and timestamp
                          RULE_NAME="FunctionApp-$display_name-$(echo $ip | tr '.' '-')-$(date +%Y%m%d)"
                          
                          # Truncate rule name if too long (Azure limit is 80 characters)
                          if [ ${#RULE_NAME} -gt 78 ]; then
                            RULE_NAME="FuncApp-$(echo $ip | tr '.' '-')-$(date +%H%M%S)"
                          fi
                          
                          echo "Adding IP $ip to PostgreSQL firewall with rule: $RULE_NAME"
                          az postgres flexible-server firewall-rule create \
                            --resource-group "$(resourceGroupName)" \
                            --name "$DB_SERVER_NAME" \
                            --rule-name "$RULE_NAME" \
                            --start-ip-address "$ip" \
                            --end-ip-address "$ip" \
                            --output none || echo "Warning: Could not add IP $ip to PostgreSQL firewall (may already exist)"
                        fi
                      done
                      
                      echo "✅ Completed PostgreSQL firewall configuration for $display_name"
                    }
                    
                    # Add IPs for Main API if deployed
                    if [ "${{ parameters.deployMainAPI }}" = "True" ]; then
                      add_function_ips_to_postgres "$(mainApiName)" "MainAPI"
                    fi
                    
                    # Add IPs for FileTransfer API if deployed
                    if [ "${{ parameters.deployFileTransferAPI }}" = "True" ]; then
                      add_function_ips_to_postgres "$(fileTransferApiName)" "FileTransferAPI"
                    fi
                    
                    echo "✅ Function App IP whitelisting to PostgreSQL completed"
                  fi
                else
                  echo "❌ Secret 'ConnectionStrings--CaseManagementDatastoreConnection' does not exist in Key Vault"
                  echo "This could be due to:"
                  echo "1. The variable 'CaseManagementDatastoreConnection' was not set in the variable group"
                  echo "2. The secret was not created successfully in the Pre_Deployment_Validation stage"
                  echo "3. Access permissions issue"
                  echo ""
                  echo "Skipping PostgreSQL firewall configuration for Function Apps"
                  echo "⚠️ Function Apps may not be able to connect to PostgreSQL without manual firewall configuration"
                fi
                
                echo "✅ Complete Function App IP whitelisting finished"



          - task: AzureCLI@2
            displayName: 'Temporarily Allow Function App Access for Health Checks'
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Temporarily allowing pipeline access to Function Apps for health checks..."
                
                # Get current pipeline IP for this stage (should be same as above but let's be safe)
                PIPELINE_IP="$(postDeploymentValidationIP)"
                if [ -z "$PIPELINE_IP" ]; then
                  PIPELINE_IP=$(curl -s https://api.ipify.org || curl -s https://ipinfo.io/ip || curl -s https://icanhazip.com)
                  echo "Health Check Stage IP Address: $PIPELINE_IP"
                fi
                
                if [ -z "$PIPELINE_IP" ]; then
                  echo "❌ Could not determine pipeline IP address"
                  exit 1
                fi
                
                # Function to add pipeline IP to Function App access restrictions
                add_pipeline_ip_to_function_app() {
                  local function_name="$1"
                  local display_name="$2"
                  
                  echo "Adding pipeline IP to $display_name access restrictions..."
                  
                  # Check if function app exists
                  if ! az functionapp show --name "$function_name" --resource-group "$(resourceGroupName)" &> /dev/null; then
                    echo "⚠️ Function App $function_name not found, skipping access restriction setup..."
                    return 0
                  fi
                  
                  # Check current access restriction configuration
                  echo "Checking current access restriction configuration for $display_name..."
                  CURRENT_RESTRICTIONS=$(az functionapp config access-restriction show --name "$function_name" --resource-group "$(resourceGroupName)" --query "mainSiteAccessRestrictions" -o json 2>/dev/null || echo "[]")
                  
                  if [ "$CURRENT_RESTRICTIONS" = "[]" ] || [ -z "$CURRENT_RESTRICTIONS" ]; then
                    echo "ℹ️ No existing access restrictions found for $display_name"
                    echo "This suggests access restrictions may need to be initialized..."
                    
                    # For Premium Function Apps, we might need to configure the scm site access restrictions first
                    echo "Attempting to initialize access restrictions for $display_name..."
                    
                    # First, try to set a basic configuration to enable access restrictions
                    az functionapp config set \
                      --name "$function_name" \
                      --resource-group "$(resourceGroupName)" \
                      --use-32bit-worker-process false \
                      --output none 2>/dev/null || echo "Could not update function app config"
                  else
                    echo "✅ Access restrictions are already configured for $display_name"
                    echo "Current restriction count: $(echo "$CURRENT_RESTRICTIONS" | jq length 2>/dev/null || echo "unknown")"
                  fi
                  
                  # Create unique rule name for pipeline access
                  RULE_NAME="AzureDevOps-HealthCheck-$(date +%Y%m%d-%H%M%S)"
                  
                  echo "Adding access restriction rule: $RULE_NAME for $display_name"
                  echo "Pipeline IP: $PIPELINE_IP"
                  
                  # Try to add the access restriction with better error handling
                  echo "Attempting to add access restriction..."
                  
                  ADD_RESULT=$(az functionapp config access-restriction add \
                    --resource-group "$(resourceGroupName)" \
                    --name "$function_name" \
                    --rule-name "$RULE_NAME" \
                    --action Allow \
                    --ip-address "$PIPELINE_IP" \
                    --priority 100 \
                    --output json 2>&1)
                  
                  ADD_EXIT_CODE=$?
                  
                  if [ $ADD_EXIT_CODE -eq 0 ]; then
                    echo "✅ Access restriction added successfully for $display_name"
                    
                    # Store rule name for cleanup
                    if [ "$function_name" = "$(mainApiName)" ]; then
                      echo "##vso[task.setvariable variable=mainApiAccessRuleName]$RULE_NAME"
                    elif [ "$function_name" = "$(fileTransferApiName)" ]; then
                      echo "##vso[task.setvariable variable=fileTransferApiAccessRuleName]$RULE_NAME"
                    fi
                    
                    # Verify the rule was added
                    echo "Verifying access restriction was added..."
                    VERIFICATION=$(az functionapp config access-restriction show --name "$function_name" --resource-group "$(resourceGroupName)" --query "mainSiteAccessRestrictions[?contains(name, '$RULE_NAME')]" -o json 2>/dev/null || echo "[]")
                    
                    if [ "$VERIFICATION" != "[]" ] && [ -n "$VERIFICATION" ]; then
                      echo "✅ Access restriction verified in Function App configuration"
                    else
                      echo "⚠️ Access restriction may not have been added correctly"
                    fi
                    
                  else
                    echo "❌ Failed to add access restriction for $display_name"
                    echo "Error details: $ADD_RESULT"
                    
                    # Check if it's a Premium plan issue
                    PLAN_INFO=$(az functionapp show --name "$function_name" --resource-group "$(resourceGroupName)" --query "{sku: appServicePlan, kind: kind}" -o json 2>/dev/null || echo "{}")
                    echo "Function App details: $PLAN_INFO"
                    
                    # Try alternative approach for Premium plans
                    echo "Attempting alternative access restriction method for Premium Function Apps..."
                    
                    # Try using webapp commands instead (Function Apps are essentially web apps)
                    ALT_RESULT=$(az webapp config access-restriction add \
                      --resource-group "$(resourceGroupName)" \
                      --name "$function_name" \
                      --rule-name "$RULE_NAME" \
                      --action Allow \
                      --ip-address "$PIPELINE_IP" \
                      --priority 100 \
                      --output json 2>&1)
                    
                    ALT_EXIT_CODE=$?
                    
                    if [ $ALT_EXIT_CODE -eq 0 ]; then
                      echo "✅ Access restriction added successfully using alternative method for $display_name"
                      
                      # Store rule name for cleanup
                      if [ "$function_name" = "$(mainApiName)" ]; then
                        echo "##vso[task.setvariable variable=mainApiAccessRuleName]$RULE_NAME"
                      elif [ "$function_name" = "$(fileTransferApiName)" ]; then
                        echo "##vso[task.setvariable variable=fileTransferApiAccessRuleName]$RULE_NAME"
                      fi
                    else
                      echo "❌ Alternative method also failed for $display_name"
                      echo "Alternative error: $ALT_RESULT"
                      echo "⚠️ Proceeding without access restrictions - health checks may fail"
                    fi
                  fi
                }
                
                # Add IP for Main API if deployed
                if [ "${{ parameters.deployMainAPI }}" = "True" ]; then
                  add_pipeline_ip_to_function_app "$(mainApiName)" "Main API"
                fi
                
                # Add IP for FileTransfer API if deployed
                if [ "${{ parameters.deployFileTransferAPI }}" = "True" ]; then
                  add_pipeline_ip_to_function_app "$(fileTransferApiName)" "FileTransfer API"
                fi
                
                echo "✅ Function App access restrictions configured for health checks"
                echo "Waiting for access restriction rules to propagate..."
                sleep 15

          - task: AzureCLI@2
            displayName: 'LACC - Health Check Main API'
            condition: eq(${{ parameters.deployMainAPI }}, true)
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                FUNCTION_URL=$(az functionapp show --name $(mainApiName) --resource-group $(resourceGroupName) --query defaultHostName -o tsv)
                
                echo "Testing Main API health check at: https://$FUNCTION_URL/api/status"
                echo "Note: Access restrictions may take a moment to propagate..."
                
                # Wait for function app to be ready and access restrictions to propagate
                sleep 20
                
                # Health check with retry logic for access restriction propagation
                MAX_RETRIES=5
                RETRY_DELAY=15
                RETRY_COUNT=0
                SUCCESS=false
                
                while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                  echo "Health check attempt $((RETRY_COUNT + 1))/$MAX_RETRIES for Main API..."
                  
                  # Check status endpoint with timeout
                  HTTP_STATUS=$(timeout 30 curl -s -o /dev/null -w "%{http_code}" "https://$FUNCTION_URL/api/status" 2>/dev/null || echo "000")
                  
                  echo "HTTP Status: $HTTP_STATUS"
                
                if [ "$HTTP_STATUS" -eq 200 ]; then
                    echo "✅ Main API health check passed on attempt $((RETRY_COUNT + 1))"
                  echo "Main API is accessible at: https://$FUNCTION_URL"
                  echo "Status endpoint: https://$FUNCTION_URL/api/status"
                    SUCCESS=true
                    break
                  elif [ "$HTTP_STATUS" -eq 403 ] || [ "$HTTP_STATUS" -eq 000 ]; then
                    echo "⏳ Access restricted or connection failed (status: $HTTP_STATUS). Waiting for access restrictions to propagate..."
                    if [ $RETRY_COUNT -lt $((MAX_RETRIES - 1)) ]; then
                      echo "Waiting $RETRY_DELAY seconds before retry..."
                      sleep $RETRY_DELAY
                    fi
                  else
                    echo "❌ Unexpected HTTP status: $HTTP_STATUS"
                    if [ $RETRY_COUNT -lt $((MAX_RETRIES - 1)) ]; then
                      echo "Waiting $RETRY_DELAY seconds before retry..."
                      sleep $RETRY_DELAY
                    fi
                  fi
                  
                  RETRY_COUNT=$((RETRY_COUNT + 1))
                done
                
                if [ "$SUCCESS" = false ]; then
                  echo "##vso[task.logissue type=error]❌ Main API health check failed after $MAX_RETRIES attempts"
                  echo "Last HTTP status: $HTTP_STATUS"
                  echo "Attempted URL: https://$FUNCTION_URL/api/status"
                  echo "Possible causes:"
                  echo "1. Function app not deployed correctly"
                  echo "2. /api/status endpoint does not exist"
                  echo "3. Access restrictions not allowing pipeline IP"
                  echo "4. Function app not responding (internal error)"
                  exit 1
                fi

          - task: AzureCLI@2
            displayName: 'LACC - Health Check FileTransfer API'
            condition: eq(${{ parameters.deployFileTransferAPI }}, true)
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                FUNCTION_URL=$(az functionapp show --name $(fileTransferApiName) --resource-group $(resourceGroupName) --query defaultHostName -o tsv)
                
                echo "Testing FileTransfer API health check at: https://$FUNCTION_URL/api/status"
                echo "Note: Access restrictions may take a moment to propagate..."
                
                # Wait for function app to be ready and access restrictions to propagate
                sleep 20
                
                # Health check with retry logic for access restriction propagation
                MAX_RETRIES=5
                RETRY_DELAY=15
                RETRY_COUNT=0
                SUCCESS=false
                
                while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                  echo "Health check attempt $((RETRY_COUNT + 1))/$MAX_RETRIES for FileTransfer API..."
                  
                  # Check status endpoint with timeout
                  HTTP_STATUS=$(timeout 30 curl -s -o /dev/null -w "%{http_code}" "https://$FUNCTION_URL/api/status" 2>/dev/null || echo "000")
                  
                  echo "HTTP Status: $HTTP_STATUS"
                  
                  if [ "$HTTP_STATUS" -eq 200 ]; then
                    echo "✅ FileTransfer API health check passed on attempt $((RETRY_COUNT + 1))"
                    echo "FileTransfer API is accessible at: https://$FUNCTION_URL"
                    echo "Status endpoint: https://$FUNCTION_URL/api/status"
                    SUCCESS=true
                    break
                  elif [ "$HTTP_STATUS" -eq 403 ] || [ "$HTTP_STATUS" -eq 000 ]; then
                    echo "⏳ Access restricted or connection failed (status: $HTTP_STATUS). Waiting for access restrictions to propagate..."
                    if [ $RETRY_COUNT -lt $((MAX_RETRIES - 1)) ]; then
                      echo "Waiting $RETRY_DELAY seconds before retry..."
                      sleep $RETRY_DELAY
                    fi
                  else
                    echo "❌ Unexpected HTTP status: $HTTP_STATUS"
                    if [ $RETRY_COUNT -lt $((MAX_RETRIES - 1)) ]; then
                      echo "Waiting $RETRY_DELAY seconds before retry..."
                      sleep $RETRY_DELAY
                    fi
                  fi
                  
                  RETRY_COUNT=$((RETRY_COUNT + 1))
                done
                
                if [ "$SUCCESS" = false ]; then
                  echo "##vso[task.logissue type=error]❌ FileTransfer API health check failed after $MAX_RETRIES attempts"
                  echo "Last HTTP status: $HTTP_STATUS"
                  echo "Attempted URL: https://$FUNCTION_URL/api/status"
                  echo "Possible causes:"
                  echo "1. Function app not deployed correctly"
                  echo "2. /api/status endpoint does not exist"
                  echo "3. Access restrictions not allowing pipeline IP"
                  echo "4. Function app not responding (internal error)"
                  exit 1
                fi

          - task: AzureCLI@2
            displayName: 'LACC - Configure PostgreSQL Firewall for Connection Test'
            condition: eq(${{ parameters.runDatabaseMigration }}, true)
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Configuring PostgreSQL Flexible Server firewall for connection test..."
                
                # Get the current public IP of the build agent
                PIPELINE_IP=$(curl -s https://api.ipify.org || curl -s https://ipinfo.io/ip || curl -s https://icanhazip.com)
                echo "Pipeline IP Address: $PIPELINE_IP"
                
                if [ -z "$PIPELINE_IP" ]; then
                  echo "❌ Could not determine pipeline IP address"
                  exit 1
                fi
                
                # SECURITY: Get PostgreSQL host directly without storing full connection string
                echo "Retrieving and parsing host from Key Vault: $(keyVaultName)"
                DB_HOST=$(az keyvault secret show --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query value -o tsv 2>/dev/null | grep -oP '(?<=Host=)[^;]+' | head -1)
                
                if [ -z "$DB_HOST" ]; then
                  echo "❌ PostgreSQL connection string not found in Key Vault or could not parse host"
                  echo "This could indicate:"
                  echo "1. PostgreSQL connection string not found in Key Vault"
                  echo "2. Connection string format is incorrect (should include: Host=hostname;...)"
                  echo "3. Key Vault access permissions issue"
                  echo "Please ensure ConnectionStrings--CaseManagementDatastoreConnection is set in Key Vault"
                  exit 1
                fi
                
                # Extract server name from hostname (remove .postgres.database.azure.com)
                DB_SERVER_NAME=$(echo "$DB_HOST" | sed 's/\.postgres\.database\.azure\.com.*//')
                echo "PostgreSQL Server Name: $DB_SERVER_NAME"
                
                # Create firewall rule name with timestamp
                RULE_NAME="AzureDevOps-Test-$(date +%Y%m%d-%H%M%S)"
                echo "Creating firewall rule: $RULE_NAME"
                
                # Add firewall rule for the pipeline IP
                az postgres flexible-server firewall-rule create \
                  --resource-group "$(resourceGroupName)" \
                  --name "$DB_SERVER_NAME" \
                  --rule-name "$RULE_NAME" \
                  --start-ip-address "$PIPELINE_IP" \
                  --end-ip-address "$PIPELINE_IP" \
                  --output table
                
                if [ $? -eq 0 ]; then
                  echo "✅ Firewall rule created successfully"
                  echo "##vso[task.setvariable variable=testFirewallRuleName]$RULE_NAME"
                  echo "##vso[task.setvariable variable=testPipelineIP]$PIPELINE_IP"
                else
                  echo "❌ Failed to create firewall rule"
                  exit 1
                fi

          - task: AzureCLI@2
            displayName: 'LACC - Database Connection Test'
            condition: eq(${{ parameters.runDatabaseMigration }}, true)
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Install PostgreSQL client (optimized)
                echo "Installing PostgreSQL client..."
                sudo apt-get update -qq
                sudo apt-get install -y postgresql-client
                
                # SECURITY: Disable command echoing to prevent credential exposure
                set +x
                
                # SECURITY: Parse connection string components WITHOUT storing the full secret in variables
                echo "Retrieving and parsing connection string securely from Key Vault: $(keyVaultName)"
                
                # Add retry logic for Key Vault access
                for attempt in {1..3}; do
                  echo "Key Vault access attempt $attempt..."
                  
                  # Extract components directly from Key Vault command output without storing full connection string
                  DB_HOST=$(az keyvault secret show --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query value -o tsv 2>/dev/null | grep -oP '(?<=Host=)[^;]+' | head -1)
                  DB_NAME=$(az keyvault secret show --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query value -o tsv 2>/dev/null | grep -oP '(?<=Database=)[^;]+' | head -1)
                  DB_USER=$(az keyvault secret show --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query value -o tsv 2>/dev/null | grep -oP '(?<=User Id=)[^;]+' | head -1)
                  DB_PASS=$(az keyvault secret show --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query value -o tsv 2>/dev/null | grep -oP '(?<=Password=)[^;]+' | head -1)
                  
                  # Check if we successfully retrieved all components
                  if [ -n "$DB_HOST" ] && [ -n "$DB_NAME" ] && [ -n "$DB_USER" ] && [ -n "$DB_PASS" ]; then
                    echo "✅ Successfully retrieved connection string components on attempt $attempt"
                    break
                  else
                    if [ $attempt -eq 3 ]; then
                      echo "❌ Failed to retrieve connection string components after 3 attempts"
                    else
                      echo "Key Vault access failed, waiting 10 seconds before retry..."
                      sleep 10
                    fi
                  fi
                done
                
                # Validate that we successfully retrieved and parsed credentials without exposing them
                if [ -z "$DB_HOST" ]; then
                  echo "❌ Could not parse PostgreSQL host from connection string"
                  echo "This could indicate:"
                  echo "1. PostgreSQL connection string not found in Key Vault"
                  echo "2. Connection string format is incorrect"
                  echo "3. Key Vault access permissions issue"
                  echo "Please ensure ConnectionStrings--CaseManagementDatastoreConnection is set in Key Vault"
                  exit 1
                fi
                if [ -z "$DB_NAME" ]; then
                  echo "❌ Could not parse PostgreSQL database name from connection string"
                  exit 1
                fi
                if [ -z "$DB_USER" ]; then
                  echo "❌ Could not parse PostgreSQL username from connection string"
                  echo "Expected format: User Id=username (not Username=username)"
                  exit 1
                fi
                if [ -z "$DB_PASS" ]; then
                  echo "❌ Could not parse PostgreSQL password from connection string"
                  exit 1
                fi
                
                echo "Testing database connection..."
                echo "Host: $DB_HOST"
                echo "Database: $DB_NAME"
                echo "User: $DB_USER"
                echo "Password: [REDACTED FOR SECURITY]"
                
                # First test server connectivity
                echo "Testing server connectivity..."
                PGPASSWORD="$DB_PASS" psql -h "$DB_HOST" -U "$DB_USER" -d "postgres" -c "SELECT 'Server connection successful' as status;" -t
                
                if [ $? -ne 0 ]; then
                  echo "❌ Cannot connect to PostgreSQL server"
                  exit 1
                fi
                
                # Then test target database connection with detailed output
                echo "Testing target database connection..."
                PGPASSWORD="$DB_PASS" psql -h "$DB_HOST" -U "$DB_USER" -d "$DB_NAME" -c "SELECT 'Database connection successful' as status, version(), current_database(), current_user, inet_server_addr(), inet_server_port();" -t
                
                if [ $? -eq 0 ]; then
                  echo "✅ Database connection test passed"
                  
                  # Additional checks
                  echo "Running additional database health checks..."
                  
                  # Check if we can query system tables
                  PGPASSWORD="$DB_PASS" psql -h "$DB_HOST" -U "$DB_USER" -d "$DB_NAME" -c "SELECT count(*) as table_count FROM information_schema.tables WHERE table_schema = 'public';" -t
                  
                  echo "✅ Database health check completed successfully"
                else
                  echo "❌ Database connection test failed"
                  echo "Please check:"
                  echo "1. PostgreSQL server is running and accessible"
                  echo "2. Firewall rules are configured correctly"
                  echo "3. Connection credentials are correct"
                  echo "4. Network connectivity is available"
                  exit 1
                fi

          - task: AzureCLI@2
            displayName: 'LACC - Cleanup PostgreSQL Test Firewall Rule'
            condition: always()
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Cleaning up temporary test firewall rule..."
                
                # Get variables from previous step
                RULE_NAME="$(testFirewallRuleName)"
                PIPELINE_IP="$(testPipelineIP)"
                
                if [ -n "$RULE_NAME" ]; then
                  # SECURITY: Get PostgreSQL server details without storing full connection string
                  DB_HOST=$(az keyvault secret show --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query value -o tsv 2>/dev/null | grep -oP '(?<=Host=)[^;]+' | head -1)
                  
                  if [ -n "$DB_HOST" ]; then
                    DB_SERVER_NAME=$(echo "$DB_HOST" | sed 's/\.postgres\.database\.azure\.com.*//')
                    
                    echo "Removing test firewall rule: $RULE_NAME"
                    echo "From PostgreSQL server: $DB_SERVER_NAME"
                    echo "Pipeline IP was: $PIPELINE_IP"
                    
                    # Remove the temporary firewall rule
                    az postgres flexible-server firewall-rule delete \
                      --resource-group "$(resourceGroupName)" \
                      --name "$DB_SERVER_NAME" \
                      --rule-name "$RULE_NAME" \
                      --yes \
                      --output table || echo "Warning: Could not remove test firewall rule (may not exist)"
                    
                    echo "✅ Test firewall rule cleanup completed"
                  else
                    echo "Could not retrieve database host for cleanup (may not exist or access issue)"
                  fi
                else
                  echo "No test firewall rule to clean up"
                fi

          - task: AzureCLI@2
            displayName: 'Cleanup Key Vault Access for Post-Deployment Validation'
            condition: always()
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Cleaning up Key Vault firewall rule for Post-Deployment Validation..."
                
                # Get this stage's IP (using the new variable name)
                VALIDATION_IP="$(postDeploymentValidationIP)"
                
                if [ -n "$VALIDATION_IP" ]; then
                  echo "Removing Post-Deployment Validation IP from Key Vault firewall: $VALIDATION_IP"
                  
                  # Remove this stage's IP from Key Vault firewall rules
                  az keyvault network-rule remove \
                    --name "$(keyVaultName)" \
                    --ip-address "$VALIDATION_IP" \
                    --output table || echo "Warning: Could not remove Key Vault firewall rule for Post-Deployment Validation"
                  
                  echo "✅ Post-Deployment Validation Key Vault firewall rule cleanup completed"
                else
                  echo "No Post-Deployment Validation Key Vault firewall rule to clean up"
                fi

          - task: AzureCLI@2
            displayName: 'Cleanup Pre-Deployment Build Agent IP from Key Vault'
            condition: always()
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Cleaning up Pre-Deployment Build Agent IP from Key Vault firewall..."
                
                # Get the build agent IP from the variable set in pre-deployment validation
                BUILD_AGENT_IP="$(buildAgentIP)"
                
                if [ -n "$BUILD_AGENT_IP" ]; then
                  echo "Removing Pre-Deployment Build Agent IP from Key Vault firewall: $BUILD_AGENT_IP"
                  
                  # Remove the build agent IP from Key Vault firewall rules
                  az keyvault network-rule remove \
                    --name "$(keyVaultName)" \
                    --ip-address "$BUILD_AGENT_IP" \
                    --output table || echo "Warning: Could not remove Key Vault firewall rule for Build Agent (may not exist or already removed)"
                  
                  echo "✅ Pre-Deployment Build Agent Key Vault firewall rule cleanup completed"
                else
                  echo "No Pre-Deployment Build Agent IP to clean up (variable not set)"
                fi

          - task: AzureCLI@2
            displayName: 'Cleanup Function App Access Restrictions for Health Checks'
            condition: always()
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Cleaning up Function App access restrictions for health checks..."
                
                # Function to remove pipeline IP from Function App access restrictions
                remove_pipeline_ip_from_function_app() {
                  local function_name="$1"
                  local display_name="$2"
                  local rule_name_var="$3"
                  
                  echo "Removing pipeline access restriction from $display_name..."
                  
                  # Check if function app exists
                  if ! az functionapp show --name "$function_name" --resource-group "$(resourceGroupName)" &> /dev/null; then
                    echo "⚠️ Function App $function_name not found, skipping access restriction cleanup..."
                    return 0
                  fi
                  
                  if [ -n "$rule_name_var" ]; then
                    echo "Removing access restriction rule: $rule_name_var from $display_name"
                    
                    # Try to remove using functionapp command first
                    echo "Attempting to remove access restriction using functionapp command..."
                    REMOVE_RESULT=$(az functionapp config access-restriction remove \
                      --resource-group "$(resourceGroupName)" \
                      --name "$function_name" \
                      --rule-name "$rule_name_var" \
                      --output json 2>&1)
                    
                    REMOVE_EXIT_CODE=$?
                    
                    if [ $REMOVE_EXIT_CODE -eq 0 ]; then
                      echo "✅ Access restriction removed successfully from $display_name"
                    else
                      echo "⚠️ Standard removal failed, trying alternative method..."
                      echo "Error details: $REMOVE_RESULT"
                      
                      # Try alternative approach using webapp commands
                      echo "Attempting to remove access restriction using webapp command..."
                      ALT_REMOVE_RESULT=$(az webapp config access-restriction remove \
                        --resource-group "$(resourceGroupName)" \
                        --name "$function_name" \
                        --rule-name "$rule_name_var" \
                        --output json 2>&1)
                      
                      ALT_REMOVE_EXIT_CODE=$?
                      
                      if [ $ALT_REMOVE_EXIT_CODE -eq 0 ]; then
                        echo "✅ Access restriction removed successfully using alternative method from $display_name"
                      else
                        echo "❌ Failed to remove access restriction from $display_name using both methods"
                        echo "Alternative error: $ALT_REMOVE_RESULT"
                        echo "⚠️ Manual cleanup may be required for rule: $rule_name_var"
                      fi
                    fi
                    
                    # Verify the rule was removed
                    echo "Verifying access restriction was removed..."
                    VERIFICATION=$(az functionapp config access-restriction show --name "$function_name" --resource-group "$(resourceGroupName)" --query "mainSiteAccessRestrictions[?contains(name, '$rule_name_var')]" -o json 2>/dev/null || echo "[]")
                    
                    if [ "$VERIFICATION" = "[]" ] || [ -z "$VERIFICATION" ]; then
                      echo "✅ Access restriction removal verified"
                    else
                      echo "⚠️ Access restriction may still exist in Function App configuration"
                      echo "Remaining rules with similar name: $VERIFICATION"
                    fi
                  else
                    echo "No access restriction rule name to clean up for $display_name"
                  fi
                }
                
                # Clean up Main API access restriction if deployed
                if [ "${{ parameters.deployMainAPI }}" = "True" ]; then
                  MAIN_API_RULE_NAME="$(mainApiAccessRuleName)"
                  remove_pipeline_ip_from_function_app "$(mainApiName)" "Main API" "$MAIN_API_RULE_NAME"
                fi
                
                # Clean up FileTransfer API access restriction if deployed
                if [ "${{ parameters.deployFileTransferAPI }}" = "True" ]; then
                  FILETRANSFER_API_RULE_NAME="$(fileTransferApiAccessRuleName)"
                  remove_pipeline_ip_from_function_app "$(fileTransferApiName)" "FileTransfer API" "$FILETRANSFER_API_RULE_NAME"
                fi
                
                echo "✅ Function App access restriction cleanup completed"

          - task: AzureCLI@2
            displayName: 'Final Cleanup Summary'
            condition: always()
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "🧹 Final Cleanup Summary"
                echo "========================"
                echo ""
                echo "✅ Cleanup operations completed:"
                echo "  1. Database Migration PostgreSQL firewall rule (temporary pipeline access)"
                echo "  2. Database Migration Key Vault firewall rule (temporary pipeline access)"
                echo "  3. Connection Test PostgreSQL firewall rule (temporary pipeline access)"
                echo "  4. Post-Deployment Validation Key Vault firewall rule (temporary pipeline access)"
                echo "  5. Pre-Deployment Build Agent Key Vault firewall rule (temporary build agent access)"
                echo "  6. Function App access restrictions for health checks (temporary pipeline access)"
                echo ""
                echo "🔒 Persistent firewall rules (NOT cleaned up - by design):"
                echo "  - Function App outbound IPs in Key Vault firewall (permanent access required)"
                echo "  - Function App outbound IPs in PostgreSQL firewall (permanent access required)"
                echo "  - Main API outbound IPs in FileTransfer API access restrictions (inter-app communication)"
                echo ""
                echo "📋 Key Vault: $(keyVaultName)"
                echo "📋 PostgreSQL Server: Connected via connection string in Key Vault"
                echo "📋 Function Apps: $(mainApiName), $(fileTransferApiName)"
                echo ""
                echo "✅ Pipeline cleanup completed successfully!"

