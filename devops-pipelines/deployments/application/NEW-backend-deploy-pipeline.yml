trigger:
  batch: true
  branches:
    include:
      - main

pr: none

resources:
  pipelines:
    - pipeline: BackendBuild
      source: 'LACC Backend - Build, Test & Package'
      trigger: none

parameters:
  - name: environment
    displayName: 'Target Environment'
    type: string
    default: 'dev'
    values:
      - dev
      - stage
      - prod
  - name: runDatabaseMigration
    displayName: 'Run Database Migration'
    type: boolean
    default: true
  - name: deployMainAPI
    displayName: 'Deploy Main API'
    type: boolean
    default: true
  - name: deployFileTransferAPI
    displayName: 'Deploy FileTransfer API'
    type: boolean
    default: true

variables:
  - group: lacc-backend-global-variables
  - group: lacc-backend-secrets-${{ parameters.environment }}-variables
  - group: lacc-backend-config-${{ parameters.environment }}-variables
  - name: resourceGroupName
    value: 'rg-lacc-${{ parameters.environment }}'
  - name: mainApiName
    value: 'fa-lacc-api-${{ parameters.environment }}'
  - name: fileTransferApiName
    value: 'fa-lacc-filetransfer-api-${{ parameters.environment }}'
  - name: keyVaultName
    value: 'kv-lacc-${{ parameters.environment }}'
  - name: azureSubscription
    ${{ if ne(parameters.environment, 'prod') }}:
      value: 'Azure Pipeline: Large and Complex Cases - Pre-Prod'
    ${{ else }}:
      value: 'Azure Pipeline: Large and Complex Cases - Prod'

# TODO: conditionally use prod pool for prod      
pool: 'LaCC Pre-Prod Build Agents' #'LARGE-AND-COMPLEX-CASES-PRE-PROD'

stages:
  - stage: Pre_Deployment_Validation
    displayName: 'LACC - Pre-Deployment Validation'
    jobs:
      - job: Validate_Environment
        displayName: 'LACC - Validate Target Environment'
        steps:
          - task: Bash@3
            displayName: 'Ensure Azure CLI'
            inputs:
              targetType: 'inline'
              script: |
                echo "Checking if Azure CLI is installed..."
                
                # Check if az command exists
                if command -v az &> /dev/null; then
                  echo "Azure CLI is already installed"
                  az --version
                  exit 0
                fi

                echo "Azure CLI not found, installing..."
                bash $(System.DefaultWorkingDirectory)/devops-pipelines/deployments/scripts/installAzureCli.sh   

          - task: AzureCLI@2
            displayName: 'LACC - Initialize Key Vault Secrets from Variable Groups'
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Initializing Key Vault secrets from Azure DevOps variable groups..."
                echo "üîê Only storing sensitive secrets in Key Vault"
                
                # Function to safely set Key Vault secret
                set_kv_secret() {
                  local secret_name="$1"
                  local secret_value="$2"
                  local description="$3"
                  
                  if [ -n "$secret_value" ] && [ "$secret_value" != "" ] && [ "$secret_value" != "null" ]; then
                    echo "Setting Key Vault secret: $secret_name"
                    az keyvault secret set \
                      --vault-name "$(keyVaultName)" \
                      --name "$secret_name" \
                      --value "$secret_value" \
                      --description "$description" \
                      --output none
                    
                    if [ $? -eq 0 ]; then
                      echo "‚úÖ Secret '$secret_name' set successfully"
                    else
                      echo "‚ùå Failed to set secret '$secret_name'"
                    fi
                  else
                    echo "‚ö†Ô∏è Skipping '$secret_name' - value is empty or not provided"
                  fi
                }
                
                echo "üìã Setting storage connection secrets..."
                
                # Azure Storage (for Functions)
                set_kv_secret "AzureWebJobsStorage" "$(AzureWebJobsStorage)" "Azure Storage connection for Functions runtime"
                
                echo "üìã Setting database connection secrets..."
                
                # Database Connection String
                set_kv_secret "ConnectionStrings--CaseManagementDatastoreConnection" "$(CaseManagementDatastoreConnection)" "PostgreSQL database connection string"
                
                echo "üìã Setting external API authentication secrets..."
                
                # Egress API Credentials
                set_kv_secret "EgressOptions--Username" "$(EgressOptionsUsername)" "Egress API username"
                set_kv_secret "EgressOptions--Password" "$(EgressOptionsPassword)" "Egress API password"
                
                # DDEI API Credentials
                set_kv_secret "DDEIOptions--AccessKey" "$(DDEIOptionsAccessKey)" "DDEI API access key"
                
                # NetApp API Credentials
                set_kv_secret "NetAppOptions--AccessKey" "$(NetAppOptionsAccessKey)" "NetApp API access key"
                set_kv_secret "NetAppOptions--SecretKey" "$(NetAppOptionsSecretKey)" "NetApp API secret key"
                
                # File Transfer API Credentials
                set_kv_secret "FileTransferApiOptions--AccessKey" "$(FileTransferApiOptionsAccessKey)" "File Transfer API access key"
                
                echo "‚úÖ Key Vault secret initialization completed"
                echo "üìã Secrets stored in Key Vault:"
                echo "  - AzureWebJobsStorage"
                echo "  - EgressOptions--Username"
                echo "  - EgressOptions--Password"
                echo "  - DDEIOptions--AccessKey"
                echo "  - ConnectionStrings--CaseManagementDatastoreConnection"
                echo "  - NetAppOptions--AccessKey"
                echo "  - NetAppOptions--SecretKey"
                echo "  - FileTransferApiOptions--AccessKey"
                
                # List all secrets that were set (names only, not values)
                echo "üìã Current Key Vault secrets:"
                az keyvault secret list --vault-name "$(keyVaultName)" --query "[].name" -o table
                
                # Verify PostgreSQL connection string was set correctly (SECURELY)
                echo "üîç Verifying PostgreSQL connection string secret..."
                POSTGRES_SECRET_EXISTS=$(az keyvault secret show --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query "id" -o tsv 2>/dev/null || echo "")
                
                if [ -n "$POSTGRES_SECRET_EXISTS" ]; then
                  echo "‚úÖ PostgreSQL connection string secret exists in Key Vault"
                  
                  # Test if we can retrieve the value WITHOUT storing it in a variable (for security)
                  # We only check if the secret can be retrieved, not store its content
                  if az keyvault secret show --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query value -o tsv >/dev/null 2>&1; then
                    # Get just the length without storing the actual secret
                    SECRET_LENGTH=$(az keyvault secret show --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query value -o tsv 2>/dev/null | wc -c)
                    echo "‚úÖ PostgreSQL connection string value is accessible (length: $SECRET_LENGTH characters)"
                  else
                    echo "‚ùå PostgreSQL connection string secret exists but value is empty or inaccessible"
                    echo "Check variable group: 'CaseManagementDatastoreConnection' variable"
                  fi
                else
                  echo "‚ùå PostgreSQL connection string secret was not created in Key Vault"
                  echo "This indicates the variable 'CaseManagementDatastoreConnection' was empty or not provided"
                  echo "Check variable group: lacc-backend-config-${{ lower(parameters.environment) }}-variables"
                fi       

          # - task: AzureCLI@2
          #   displayName: 'LACC - Initialize Key Vault Secrets from Variable Groups'
          #   inputs:
          #     azureSubscription: $(azureSubscription)
          #     scriptType: 'bash'
          #     scriptLocation: 'scriptPath'
          #     scriptPath: '$(System.DefaultWorkingDirectory)/devops-pipelines/deployments/scripts/populateKV.sh'
          #   env:
          #     KEY_VAULT_NAME: $(keyVaultName)
          #     CASE_MANAGEMENT_DATASTORE_CONNECTION: $(CaseManagementDatastoreConnection)
          #     EGRESS_OPTIONS_USERNAME: $(EgressOptionsUsername)
          #     EGRESS_OPTIONS_PASSWORD: $(EgressOptionsPassword)
          #     DDEI_OPTIONS_ACCESS_KEY: $(DDEIOptionsAccessKey)
          #     NET_APP_OPTIONS_ACCESS_KEY: $(NetAppOptionsAccessKey)
          #     NET_APP_OPTIONS_SECRET_KEY: $(NetAppOptionsSecretKey)
          #     FILE_TRANSFER_API_OPTIONS_ACCESS_KEY: $(FileTransferApiOptionsAccessKey)

  - stage: Database_Migration
    displayName: 'LACC - Database Migration'
    dependsOn: Pre_Deployment_Validation
    condition: and(succeeded(), eq(${{ parameters.runDatabaseMigration }}, true))
    jobs:
      - deployment: Deploy_Database_Changes
        displayName: 'LACC - Deploy Database Changes'
        environment: 'LACC-Backend-${{ parameters.environment }}'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: DownloadBuildArtifacts@0
                  displayName: 'Download Database Scripts'
                  inputs:
                    buildType: 'specific'
                    project: '$(System.TeamProjectId)'
                    pipeline: 'LACC Backend - Build, Test & Package'
                    buildVersionToDownload: 'latest'
                    artifactName: 'database-scripts-drop'
                    downloadPath: '$(Pipeline.Workspace)'

                - task: ExtractFiles@1
                  displayName: 'Extract Database Scripts'
                  inputs:
                    archiveFilePatterns: '$(Pipeline.Workspace)/database-scripts-drop/*.zip'
                    destinationFolder: '$(Pipeline.Workspace)/database-scripts'
                    cleanDestinationFolder: true

                - task: AzureCLI@2
                  displayName: 'Run Database Migration'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      # Install PostgreSQL client (optimized)
                      echo "Installing PostgreSQL client..."
                      sudo apt-get update -qq
                      sudo apt-get install -y postgresql-client
                      
                      # SECURITY: Disable command echoing to prevent credential exposure
                      set +x
                      
                      # SECURITY: Parse connection string components WITHOUT storing the full secret in variables
                      echo "Retrieving and parsing connection string securely from Key Vault: $(keyVaultName)"
                      
                      # Add retry logic for Key Vault access
                      for attempt in {1..3}; do
                        echo "Key Vault access attempt $attempt..."
                        
                        # Extract components directly from Key Vault command output without storing full connection string
                        DB_HOST=$(az keyvault secret show --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query value -o tsv 2>/dev/null | grep -oP '(?<=Host=)[^;]+' | head -1)
                        DB_NAME=$(az keyvault secret show --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query value -o tsv 2>/dev/null | grep -oP '(?<=Database=)[^;]+' | head -1)
                        DB_USER=$(az keyvault secret show --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query value -o tsv 2>/dev/null | grep -oP '(?<=User Id=)[^;]+' | head -1)
                        DB_PASS=$(az keyvault secret show --vault-name "$(keyVaultName)" --name "ConnectionStrings--CaseManagementDatastoreConnection" --query value -o tsv 2>/dev/null | grep -oP '(?<=Password=)[^;]+' | head -1)
                        
                        # Check if we successfully retrieved all components
                        if [ -n "$DB_HOST" ] && [ -n "$DB_NAME" ] && [ -n "$DB_USER" ] && [ -n "$DB_PASS" ]; then
                          echo "‚úÖ Successfully retrieved connection string components on attempt $attempt"
                          break
                        else
                          if [ $attempt -eq 3 ]; then
                            echo "‚ùå Failed to retrieve connection string components after 3 attempts"
                          else
                            echo "Key Vault access failed, waiting 10 seconds before retry..."
                            sleep 10
                          fi
                        fi
                      done
                      
                      # Validate that we successfully retrieved and parsed credentials without exposing them
                      if [ -z "$DB_HOST" ]; then
                        echo "‚ùå Could not parse PostgreSQL host from connection string"
                        echo "This could indicate:"
                        echo "1. PostgreSQL connection string not found in Key Vault"
                        echo "2. Connection string format is incorrect"
                        echo "3. Key Vault access permissions issue"
                        echo "Please ensure ConnectionStrings--CaseManagementDatastoreConnection is set in Key Vault"
                        exit 1
                      fi
                      if [ -z "$DB_NAME" ]; then
                        echo "‚ùå Could not parse PostgreSQL database name from connection string"
                        exit 1
                      fi
                      if [ -z "$DB_USER" ]; then
                        echo "‚ùå Could not parse PostgreSQL username from connection string"
                        echo "Expected format: User Id=username (not Username=username)"
                        exit 1
                      fi
                      if [ -z "$DB_PASS" ]; then
                        echo "‚ùå Could not parse PostgreSQL password from connection string"
                        exit 1
                      fi
                      
                      echo "Testing database connection..."
                      echo "Host: $DB_HOST"
                      echo "Database: $DB_NAME"
                      echo "User: $DB_USER"
                      echo "Password: [REDACTED FOR SECURITY]"
                      
                      # First test server connectivity
                      echo "Testing server connectivity..."
                      PGPASSWORD="$DB_PASS" psql -h "$DB_HOST" -U "$DB_USER" -d "postgres" -c "SELECT 'Server connection successful' as status;" -t
                      
                      if [ $? -ne 0 ]; then
                        echo "‚ùå Cannot connect to PostgreSQL server"
                        exit 1
                      fi
                      
                      # Then test target database connection with detailed output
                      echo "Testing target database connection..."
                      PGPASSWORD="$DB_PASS" psql -h "$DB_HOST" -U "$DB_USER" -d "$DB_NAME" -c "SELECT 'Database connection successful' as status, version(), current_database(), current_user, inet_server_addr(), inet_server_port();" -t
                        
                        if [ $? -eq 0 ]; then
                        echo "‚úÖ Database connection test passed"
                        
                        # Additional checks
                        echo "Running additional database health checks..."
                        
                        # Check if we can query system tables
                        PGPASSWORD="$DB_PASS" psql -h "$DB_HOST" -U "$DB_USER" -d "$DB_NAME" -c "SELECT count(*) as table_count FROM information_schema.tables WHERE table_schema = 'public';" -t
                        
                        echo "‚úÖ Database health check completed successfully"
                      else
                        echo "‚ùå Database connection test failed"
                        echo "Please check:"
                        echo "1. PostgreSQL server is running and accessible"
                        echo "2. Firewall rules are configured correctly"
                        echo "3. Connection credentials are correct"
                        echo "4. Network connectivity is available"
                        exit 1
                      fi
              
  - stage: Deploy_Function_Apps
    displayName: 'LACC - Deploy Function Apps'
    ${{ if eq(parameters.runDatabaseMigration, true) }}:
      dependsOn: 
        - Pre_Deployment_Validation
        - Database_Migration
    ${{ else }}:
      dependsOn: Pre_Deployment_Validation
    jobs:
      - deployment: Deploy_Main_API
        displayName: 'LACC - Deploy Main API Function App'
        condition: eq(${{ parameters.deployMainAPI }}, true)
        environment: 'LACC-Backend-${{ parameters.environment }}'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: Bash@3
                  displayName: 'Ensure Azure CLI'
                  inputs:
                    targetType: 'inline'
                    script: |
                      echo "Checking if Azure CLI is installed..."
                      
                      # Check if az command exists
                      if command -v az &> /dev/null; then
                        echo "Azure CLI is already installed"
                        az --version
                        exit 0
                      fi

                      echo "Azure CLI not found, installing..."
                      bash $(System.DefaultWorkingDirectory)/devops-pipelines/deployments/scripts/installAzureCli.sh

                - task: DownloadBuildArtifacts@0
                  displayName: 'LACC - Download Main API Artifact'
                  inputs:
                    buildType: 'specific'
                    project: '$(System.TeamProjectId)'
                    pipeline: 'LACC Backend - Build, Test & Package'
                    buildVersionToDownload: 'latest'
                    artifactName: 'lacc-main-api-drop'
                    downloadPath: '$(Pipeline.Workspace)'

                - template: ../templates/configuration-template.yml
                  parameters:
                    environment: ${{ parameters.environment }}
                    functionAppName: $(mainApiName)
                    subscriptionName: $(azureSubscription)
                    resourceGroupName: $(resourceGroupName)
                    keyVaultName: $(keyVaultName)
                    appInsightsKey: $(ApplicationInsightsInstrumentationKey)
                    appInsightsConnectionString: $(ApplicationInsightsConnectionString)

                - task: AzureFunctionApp@2
                  displayName: 'LACC - Deploy Main API to Azure Function App'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    appType: 'functionApp'
                    appName: $(mainApiName)
                    package: '$(Pipeline.Workspace)/lacc-main-api-drop/*.zip'
                    runtimeStack: 'DOTNET-ISOLATED|8.0'
                    deploymentMethod: 'runFromPackage'

                - task: AzureCLI@2
                  displayName: 'LACC - Verify Main API Deployment'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      echo "Verifying Main API deployment..."
                      
                      # Check if deployment completed successfully
                      DEPLOYMENT_STATUS=$(az functionapp deployment list --name $(mainApiName) --resource-group $(resourceGroupName) --query "[0].status" -o tsv)
                      echo "Latest deployment status: $DEPLOYMENT_STATUS"
                      
                      # Wait a moment for extraction to complete
                      echo "Waiting for deployment to stabilize..."
                      sleep 10
                      
                      # Check if function app is running
                      APP_STATE=$(az functionapp show --name $(mainApiName) --resource-group $(resourceGroupName) --query "state" -o tsv)
                      echo "Function app state: $APP_STATE"
                      
                      if [ "$APP_STATE" != "Running" ]; then
                        echo "‚ö†Ô∏è Function app is not in Running state"
                      else
                        echo "‚úÖ Function app is running"
                      fi

      - deployment: Deploy_FileTransfer_API
        displayName: 'LACC - Deploy FileTransfer API Function App'
        condition: eq(${{ parameters.deployFileTransferAPI }}, true)
        environment: 'LACC-Backend-${{ parameters.environment }}'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: Bash@3
                  displayName: 'Ensure Azure CLI'
                  inputs:
                    targetType: 'inline'
                    script: |
                      echo "Checking if Azure CLI is installed..."
                      
                      # Check if az command exists
                      if command -v az &> /dev/null; then
                        echo "Azure CLI is already installed"
                        az --version
                        exit 0
                      fi

                      echo "Azure CLI not found, installing..."
                      bash $(System.DefaultWorkingDirectory)/devops-pipelines/deployments/scripts/installAzureCli.sh

                - task: DownloadBuildArtifacts@0
                  displayName: 'LACC - Download FileTransfer API Artifact'
                  inputs:
                    buildType: 'specific'
                    project: '$(System.TeamProjectId)'
                    pipeline: 'LACC Backend - Build, Test & Package'
                    buildVersionToDownload: 'latest'
                    artifactName: 'lacc-filetransfer-api-drop'
                    downloadPath: '$(Pipeline.Workspace)'

                - template: ../templates/configuration-template.yml
                  parameters:
                    environment: ${{ parameters.environment }}
                    functionAppName: $(fileTransferApiName)
                    subscriptionName: $(azureSubscription)
                    resourceGroupName: $(resourceGroupName)
                    keyVaultName: $(keyVaultName)
                    appInsightsKey: $(ApplicationInsightsInstrumentationKey)
                    appInsightsConnectionString: $(ApplicationInsightsConnectionString)

                - task: AzureFunctionApp@2
                  displayName: 'LACC - Deploy FileTransfer API to Azure Function App'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    appType: 'functionApp'
                    appName: $(fileTransferApiName)
                    package: '$(Pipeline.Workspace)/lacc-filetransfer-api-drop/*.zip'
                    runtimeStack: 'DOTNET-ISOLATED|8.0'
                    deploymentMethod: 'runFromPackage'

                - task: AzureCLI@2
                  displayName: 'LACC - Verify FileTransfer API Deployment'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      echo "Verifying FileTransfer API deployment..."
                      
                      # Check if deployment completed successfully
                      DEPLOYMENT_STATUS=$(az functionapp deployment list --name $(fileTransferApiName) --resource-group $(resourceGroupName) --query "[0].status" -o tsv)
                      echo "Latest deployment status: $DEPLOYMENT_STATUS"
                      
                      # Wait a moment for extraction to complete
                      echo "Waiting for deployment to stabilize..."
                      sleep 10
                      
                      # Check if function app is running
                      APP_STATE=$(az functionapp show --name $(fileTransferApiName) --resource-group $(resourceGroupName) --query "state" -o tsv)
                      echo "Function app state: $APP_STATE"
                      
                      if [ "$APP_STATE" != "Running" ]; then
                        echo "‚ö†Ô∏è Function app is not in Running state"
                      else
                        echo "‚úÖ Function app is running"
                      fi