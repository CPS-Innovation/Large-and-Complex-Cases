{
  "version": 3,
  "sources": ["../../node_modules/use-reducer-async/src/index.ts"],
  "sourcesContent": ["import {\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useReducer,\n  useRef,\n  useState,\n  Dispatch,\n  Reducer,\n  ReducerState,\n  ReducerAction,\n} from 'react';\n\nconst isClient = (\n  typeof window !== 'undefined'\n  && !/ServerSideRendering/.test(window.navigator && window.navigator.userAgent)\n);\n\nconst useIsomorphicLayoutEffect = isClient ? useLayoutEffect : useEffect;\n\nconst useAbortSignal = () => {\n  const [controller, setController] = useState(() => new AbortController());\n  const lastController = useRef(controller);\n  useEffect(() => {\n    const abort = () => {\n      lastController.current.abort();\n      lastController.current = new AbortController();\n      setController(lastController.current);\n    };\n    return abort;\n  }, []);\n  return controller.signal;\n};\n\nexport type AsyncActionHandlers<\n  R extends Reducer<any, any>,\n  AsyncAction extends { type: string }\n> = {\n  [T in AsyncAction['type']]: AsyncAction extends infer A ? A extends {\n    type: T;\n  } ? (s: {\n    dispatch: Dispatch<AsyncAction | ReducerAction<R>>;\n    getState: () => ReducerState<R>;\n    signal: AbortSignal;\n  }) => (a: A) => Promise<void> : never : never;\n};\n\nexport function useReducerAsync<\n  R extends Reducer<any, any>,\n  I,\n  AsyncAction extends { type: string },\n  ExportAction extends AsyncAction | ReducerAction<R> = AsyncAction | ReducerAction<R>\n>(\n  reducer: R,\n  initializerArg: I,\n  initializer: (arg: I) => ReducerState<R>,\n  asyncActionHandlers: AsyncActionHandlers<R, AsyncAction>,\n): [ReducerState<R>, Dispatch<ExportAction>];\n\n/**\n * useReducer with async actions\n * @example\n * import { useReducerAsync } from 'use-reducer-async';\n *\n * const asyncActionHandlers = {\n *   SLEEP: ({ dispatch, getState, signal }) => async (action) => {\n *     dispatch({ type: 'START_SLEEP' });\n *     await new Promise(r => setTimeout(r, action.ms));\n *     dispatch({ type: 'END_SLEEP' });\n *   },\n *   FETCH: ({ dispatch, getState, signal }) => async (action) => {\n *     dispatch({ type: 'START_FETCH' });\n *     try {\n *       const response = await fetch(action.url);\n *       const data = await response.json();\n *       dispatch({ type: 'FINISH_FETCH', data });\n *     } catch (error) {\n *       dispatch({ type: 'ERROR_FETCH', error });\n *     }\n *   },\n * };\n * const [state, dispatch] = useReducerAsync(reducer, initialState, asyncActionHandlers);\n */\nexport function useReducerAsync<\n  R extends Reducer<any, any>,\n  AsyncAction extends { type: string },\n  ExportAction extends AsyncAction | ReducerAction<R> = AsyncAction | ReducerAction<R>\n>(\n  reducer: R,\n  initialState: ReducerState<R>,\n  asyncActionHandlers: AsyncActionHandlers<R, AsyncAction>,\n): [ReducerState<R>, Dispatch<ExportAction>];\n\nexport function useReducerAsync<\n  R extends Reducer<any, any>,\n  I,\n  AsyncAction extends { type: string },\n  ExportAction extends AsyncAction | ReducerAction<R> = AsyncAction | ReducerAction<R>\n>(\n  reducer: R,\n  initializerArg: I | ReducerState<R>,\n  initializer: unknown,\n  asyncActionHandlers?: AsyncActionHandlers<R, AsyncAction>,\n): [ReducerState<R>, Dispatch<ExportAction>] {\n  const signal = useAbortSignal();\n  const aaHandlers = (\n    asyncActionHandlers || initializer\n  ) as AsyncActionHandlers<R, AsyncAction>;\n  const [state, dispatch] = useReducer(\n    reducer,\n    initializerArg as any,\n    asyncActionHandlers && initializer as any,\n  );\n  const lastState = useRef(state);\n  useIsomorphicLayoutEffect(() => {\n    lastState.current = state;\n  }, [state]);\n  const getState = useCallback((() => lastState.current), []);\n  const wrappedDispatch = useCallback((action: AsyncAction | ReducerAction<R>) => {\n    const { type } = (action || {}) as { type?: AsyncAction['type'] };\n    const aaHandler = (\n      (type && aaHandlers[type]) || null\n    ) as (typeof action extends AsyncAction ? (s: {\n      dispatch: Dispatch<AsyncAction | ReducerAction<R>>;\n      getState: () => ReducerState<R>;\n      signal: AbortSignal;\n    }) => (a: typeof action) => Promise<void> : null);\n    if (aaHandler) {\n      aaHandler({ dispatch: wrappedDispatch, getState, signal })(action as AsyncAction);\n    } else {\n      dispatch(action as ReducerAction<R>);\n    }\n  }, [aaHandlers, getState, signal]);\n  return [state, wrappedDispatch];\n}\n"],
  "mappings": ";;;;;;;;;AAaA,IAKMA,IAJc,eAAA,OAAlBC,UACI,sBAAsBC,KAAKD,OAAOE,aAAaF,OAAOE,UAAUC,SAAAA,IAGPC,aAAAA,YAAlBC,aAAAA;AA2E7BC,SAAAA,EAMdC,IACAC,IACAC,GACAC,GAAAA;AAEA,QAAMC,KApFe,MAAA;AACrB,UAAA,CAAOC,IAAYC,EAAAA,QAAiBC,aAAAA,UAAS,MAAM,IAAIC,iBAAAA,GACnCC,SAAGC,aAAAA,QAAOL,EAAAA;AAS9B,eARAR,aAAAA,WAAU,MACM,MAAA;AACZY,MAAAA,GAAeE,QAAQC,MAAAA,GACvBH,GAAeE,UAAU,IAAzBH,mBACAF,GAAcG,GAAeE,OAAAA;IAAAA,GAG9B,CAAA,CAAA,GACIN,GAAWD;EAAAA,GAyEHS,GACCC,IACdX,KAAuBD,GAAAA,CAElBa,GAAOC,CAAAA,QAAYC,aAAAA,YACxBjB,IACAC,IACAE,KAAuBD,CAAAA,GAEVgB,QAAGR,aAAAA,QAAOK,CAAAA;AACzBvB,IAA0B,MAAA;AACxB0B,MAAUP,UAAUI;EAAAA,GACnB,CAACA,CAAAA,CAAAA;AACJ,QAAcI,QAAGC,aAAAA,aAAa,MAAMF,EAAUP,SAAU,CAAA,CAAA,GAClDU,QAAkBD,aAAAA,aAAaE,CAAAA,OAAAA;AACnC,UAAA,EAAMC,MAAEA,GAAAA,IAAUD,MAAU,CAAA,GACbE,KACZD,MAAQT,EAAWS,EAAAA,KAAU;AAM5BC,IAAAA,KACFA,GAAU,EAAER,UAAUK,GAAiBF,UAAAA,GAAUf,QAAAA,EAAAA,CAAAA,EAAUkB,EAAAA,IAE3DN,EAASM,EAAAA;EAAAA,GAEV,CAACR,GAAYK,GAAUf,CAAAA,CAAAA;AAC1B,SAAO,CAACW,GAAOM,CAAAA;AAAAA;",
  "names": ["useIsomorphicLayoutEffect", "window", "test", "navigator", "userAgent", "useEffect", "useLayoutEffect", "useReducerAsync", "reducer", "initializerArg", "initializer", "asyncActionHandlers", "signal", "controller", "setController", "useState", "AbortController", "lastController", "useRef", "current", "abort", "useAbortSignal", "aaHandlers", "state", "dispatch", "useReducer", "lastState", "getState", "useCallback", "wrappedDispatch", "action", "type", "aaHandler"]
}
